:midnight: https://midnight.network/[Midnight]
:nvm: https://github.com/nvm-sh/nvm[nvm]
:yarn: https://yarnpkg.com/getting-started/install[yarn]
:compact-installation: https://docs.midnight.network/develop/tutorial/building/#midnight-compact-compiler[compact installation]

= Contracts for Compact

*A library for secure smart contract development* written in Compact for {midnight}.
This library consists of modules to build custom smart contracts.

WARNING: This repo contains highly experimental code. Expect rapid iteration. *Use at your own risk.*

== ZK Circuit Primer

Compact code is compiled into zero-knowledge circuits, which are mathematical representations of the contract's logic.
These circuits are made up of arithmetic gates that enforce the rules and constraints defined in the Compact program.
At a high level, we can think of ZK circuits as a magic puzzle board that proves we've done a series of steps correctly - like a recipe.
The puzzle board is laid out in a grid like a giant sheet of graph paper with a certain number of rows.
Each row is a space where you can write a step or rule that needs to be followed.

The size of the board is called the **domain size** which we refer to as `k` in our documentation. It’s always a power of 2 (like 256, 512, 1024, etc.), because the math behind the scenes needs it that way.
Now, just because our board has 1024 rows doesn’t mean we use all of them. Maybe our recipe takes only 563 steps, so we fill in 563 rows and leave the rest blank. These filled in rows are called **used rows**.
So when we say "k = 10, rows = 563" in our API Reference documentation, that means "this circuit has a size of 2^10 = 1024 rows and only uses 563 rows".

Why is this important? Well, when we're writing ZK circuits we want to make the size and number of gates (rules) as small as possible.
The number of gates in a zero-knowledge circuit directly impacts both the prover time (how long it takes to generate a proof) and, to a lesser extent, the proof size and verifier time.
Larger circuits with more gates require more computation to generate a proof, which can make proof generation slower and more resource-intensive.
This is especially relevant for privacy-preserving blockchains like Midnight, where proof generation is often the most computationally expensive part of a transaction.

== Installation

Make sure you have {nvm} and {yarn} installed on your machine.

Follow Midnight's {compact-installation} guide and confirm that `compactc` is in the `PATH` env variable.

```bash
$ compactc

Compactc version: 0.23.0
Usage: compactc.bin <flag> ... <source-pathname> <target-directory-pathname>
       --help displays detailed usage information
```

=== Project setup

Clone the repository:

```bash
git clone git@github.com:OpenZeppelin/midnight-contracts.git
```

`cd` into it and then install dependencies and prepare the environment:

```bash
nvm install && \
yarn && \
yarn prepare
```

== Usage

Compile the contracts:

```bash
$ npx turbo compact

(...)
✔ [COMPILE] [1/2] Compiled FungibleToken.compact
@openzeppelin-compact/fungible-token:compact:     Compactc version: 0.23.0
@openzeppelin-compact/fungible-token:compact:
✔ [COMPILE] [1/6] Compiled Initializable.compact
@openzeppelin-compact/utils:compact:     Compactc version: 0.23.0
@openzeppelin-compact/utils:compact:
✔ [COMPILE] [2/6] Compiled Pausable.compact
@openzeppelin-compact/utils:compact:     Compactc version: 0.23.0
@openzeppelin-compact/utils:compact:
✔ [COMPILE] [3/6] Compiled Utils.compact
@openzeppelin-compact/utils:compact:     Compactc version: 0.23.0
@openzeppelin-compact/utils:compact:
✔ [COMPILE] [4/6] Compiled test/mocks/MockInitializable.compact
@openzeppelin-compact/utils:compact:     Compactc version: 0.23.0
@openzeppelin-compact/utils:compact:     Compiling 3 circuits:
✔ [COMPILE] [5/6] Compiled test/mocks/MockPausable.compact
@openzeppelin-compact/utils:compact:     Compactc version: 0.23.0
@openzeppelin-compact/utils:compact:     Compiling 5 circuits:
✔ [COMPILE] [6/6] Compiled test/mocks/MockUtils.compact
@openzeppelin-compact/utils:compact:     Compactc version: 0.23.0
@openzeppelin-compact/utils:compact:

✔ [COMPILE] [2/2] Compiled test/mocks/MockFungibleToken.compact
@openzeppelin-compact/fungible-token:compact:     Compactc version: 0.23.0
@openzeppelin-compact/fungible-token:compact:     Compiling 15 circuits:


 Tasks:    2 successful, 2 total
Cached:    0 cached, 2 total
  Time:    7.178s
```

NOTE: Speed up the development process by skipping the prover and verifier key file generation: +
`npx turbo compact -- --skip-zk`

Run tests:

```bash
npx turbo test
```
