= FungibleToken

This module provides the full FungibleToken API.

== Module

[.contract]
[[FungibleToken]]
=== `++FungibleToken++`

[.contract-index]
.Circuits
--
[.sub-index#FungibleTokenModule]
* xref:#FungibleTokenModule-initializer[`++initializer(name_, symabol_, decimals_)++`]
* xref:#FungibleTokenModule-name[`++name()++`]
* xref:#FungibleTokenModule-symbol[`++symbol()++`]
* xref:#FungibleTokenModule-decimals[`++decimals()++`]
* xref:#FungibleTokenModule-totalSupply[`++totalSupply()++`]
* xref:#FungibleTokenModule-balanceOf[`++balanceOf(account)++`]
* xref:#FungibleTokenModule-allowance[`++allowance(owner, spender)++`]
* xref:#FungibleTokenModule-transfer[`++transfer(to, value)++`]
* xref:#FungibleTokenModule-transferFrom[`++transferFrom(from, to, value)++`]
* xref:#FungibleTokenModule-approve[`++approve(spender, value)++`]
* xref:#FungibleTokenModule-_approve[`++_approve(owner, spender, value)++`]
* xref:#FungibleTokenModule-approve[`++_transfer(from, to, value)++`]
* xref:#FungibleTokenModule-_mint[`++_mint(account, value)++`]
* xref:#FungibleTokenModule-_burn[`++_burn(account, value)++`]
* xref:#FungibleTokenModule-_update[`++_update(from, to, value)++`]
* xref:#FungibleTokenModule-approve[`++_spendAllowance(owner, spender, value)++`]

--

[.contract-item]
[[FungibleTokenModule-initializer]]
==== `[.contract-item-name]#++initializer++#++(name_: Opaque<"string">, symabol_: Opaque<"string">, decimals_: Uint<8>) → []++` [.item-kind]#circuit#

Initializes the contract by setting the name, symbol, and decimals.
This MUST be called in the implementing contract's constructor.
Failure to do so can lead to an irreparable contract.

[.contract-item]
[[FungibleTokenModule-name]]
==== `[.contract-item-name]#++name++#++() → Opaque<"string">++` [.item-kind]#circuit#

Returns the token name.

[.contract-item]
[[FungibleTokenModule-symbol]]
==== `[.contract-item-name]#++symbol++#++() → Opaque<"string">++` [.item-kind]#circuit#

Returns the symbol of the token.

[.contract-item]
[[FungibleTokenModule-decimals]]
==== `[.contract-item-name]#++decimals++#++() → Uint<8>++` [.item-kind]#circuit#

Returns the number of decimals used to get its user representation.

[.contract-item]
[[FungibleTokenModule-totalSupply]]
==== `[.contract-item-name]#++totalSupply++#++() → Uint<128>++` [.item-kind]#circuit#

Returns the value of tokens in existence.

[.contract-item]
[[FungibleTokenModule-balance_of]]
==== `[.contract-item-name]#++balance_of++#++(account: Either<ZswapCoinPublicKey, ContractAddress>) → Uint<128>++` [.item-kind]#circuit#

Returns the value of tokens owned by `account`.

[.contract-item]
[[FungibleTokenModule-allowance]]
==== `[.contract-item-name]#++allowance++#++(owner: Either<ZswapCoinPublicKey, ContractAddress>, spender: Either<ZswapCoinPublicKey, ContractAddress>) → Uint<128>++` [.item-kind]#circuit#

Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through `transferFrom`.
This value changes when `approve` or `transferFrom` are called.

[.contract-item]
[[FungibleTokenModule-transfer]]
==== `[.contract-item-name]#++transfer++#++(to: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>) → Boolean++` [.item-kind]#circuit#

 Moves a `value` amount of tokens from the caller's account to `to`.

[.contract-item]
[[FungibleTokenModule-transferFrom]]
==== `[.contract-item-name]#++transferFrom++#++(from: Either<ZswapCoinPublicKey, ContractAddress>,, to: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>) → Boolean++` [.item-kind]#circuit#

Moves `value` tokens from `from` to `to` using the allowance mechanism.
`value` is the deducted from the caller's allowance.

[.contract-item]
[[FungibleTokenModule-approve]]
==== `[.contract-item-name]#++approve++#++(spender: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>) → Boolean++` [.item-kind]#circuit#

Sets a `value` amount of tokens as allowance of `spender` over the caller's tokens.

[.contract-item]
[[FungibleTokenModule-_approve]]
==== `[.contract-item-name]#++_approve++#++(owner: Either<ZswapCoinPublicKey, ContractAddress>, spender: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>) → []++` [.item-kind]#circuit#

Sets `value` as the allowance of `spender` over the ``owner``'s tokens.
This internal function is equivalent to `approve`, and can be used to e.g. set automatic allowances for certain subsystems, etc.

[.contract-item]
[[FungibleTokenModule-_transfer]]
==== `[.contract-item-name]#++_transfer++#++(from: Either<ZswapCoinPublicKey, ContractAddress>, to: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>) → []++` [.item-kind]#circuit#

Moves a `value` amount of tokens from `from` to `to`.
This internal function is equivalent to {transfer}, and can be used to e.g. implement automatic token fees, slashing mechanisms, etc.

[.contract-item]
[[FungibleTokenModule-_mint]]
==== `[.contract-item-name]#++_mint++#++(account: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>) → []++` [.item-kind]#circuit#

Creates a `value` amount of tokens and assigns them to `account`, by transferring it from the zero address.
Relies on the `update` mechanism.

[.contract-item]
[[FungibleTokenModule-_burn]]
==== `[.contract-item-name]#++_burn++#++(account: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>) → []++` [.item-kind]#circuit#

Destroys a `value` amount of tokens from `account`, lowering the total supply.
Relies on the `_update` mechanism.

[.contract-item]
[[FungibleTokenModule-_update]]
==== `[.contract-item-name]#++_update++#++(from: Either<ZswapCoinPublicKey, ContractAddress>, to: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>) → []++` [.item-kind]#circuit#

Transfers a `value` amount of tokens from `from` to `to`,
or alternatively mints (or burns) if `from` (or `to`) is the zero address.

[.contract-item]
[[FungibleTokenModule-_spendAllowance]]
==== `[.contract-item-name]#++_spendAllowance++#++(owner: Either<ZswapCoinPublicKey, ContractAddress>, spender: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>) → []++` [.item-kind]#circuit#

Updates `owner`'s allowance for `spender` based on spent `value`.
Does not update the allowance value in case of infinite allowance.
