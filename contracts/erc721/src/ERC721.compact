// SPDX-License-Identifier: MIT

pragma language_version >= 0.15.0;

/**
 * @module ERC721
 * @description An unshielded ERC721 library.
 *
 * @notice One notable difference regarding this implementation and the EIP20 spec
 * consists of the token size. Uint<128> is used as the token size because Uint<256>
 * cannot be supported.
 * This is due to encoding limits on the midnight circuit backend:
 * https://github.com/midnightntwrk/compactc/issues/929
 *
 * @notice Further discussion and consideration required:
 *
 * - Consider changing the underscore in the internal methods to `unsafe` or
 * adopting dot notation for prefixing imports.
 * - Revise logic once contract-to-contract interactions are available on Midnight.
 * - Revise logic once events are available on Midnight.
 * - Consider implementing an introspection mechanism for transfers to contracts.
 */

/**
 * The owner of a non-fungible token
 * @typedef {ZswapCoinPublicKey} Owner
 */

/**
 * The token identifier of a non-funglible token
 * @typedef {Uint<128>} TokenId
 */

/**
 * An account authorized to manage a non-fungible token 
 * @typedef {ZswapCoinPublicKey} Operator
 */
module ERC721 {
  import CompactStandardLibrary;
  import "../../node_modules/@openzeppelin-midnight/utils/src/Utils" prefix Utils_;

  /// Public state
  export sealed ledger _name: Maybe<Opaque<"string">>;
  export sealed ledger _symbol: Maybe<Opaque<"string">>;
  export ledger _owners: Map<Uint<128>, ZswapCoinPublicKey>;
  export ledger _balances: Map<ZswapCoinPublicKey, Uint<128>>;
  export ledger _tokenApprovals: Map<Uint<128>, ZswapCoinPublicKey>;
  export ledger _operatorApprovals: Map<ZswapCoinPublicKey, Map<ZswapCoinPublicKey, Boolean>>;
  export ledger _tokenURI: Map<Uint<128>, Maybe<Opaque<"string">>>;

  /**
   * @description Initializes the contract by setting the name and symbol.
   *
   * @param {Maybe<Opaque<"string">>} name_ - The name of the token.
   * @param {Maybe<Opaque<"string">>} symbol_ - The symbol of the token.
   * @return {[]} - None.
   */
  export circuit initializer(
    name_: Maybe<Opaque<"string">>,
    symbol_: Maybe<Opaque<"string">>
  ): [] {
    _name = name_;
    _symbol = symbol_;
  }

  /**
   * @description Returns the token name.
   *
   * @return {Maybe<Opaque<"string">>} - The token name.
   */
  export circuit name(): Maybe<Opaque<"string">> {
    return _name;
  }

  /**
   * @description Returns the symbol of the token.
   *
   * @return {Maybe<Opaque<"string">>} - The token symbol.
   */
  export circuit symbol(): Maybe<Opaque<"string">> {
    return _symbol;
  }


  /**
   * @description Returns the number of tokens in `owner`'s account.
   *
   * @param {Owner} owner - The public key to query.
   * @return {Uint<128>} - The number of tokens in`owner`'s account.
   */
  export circuit balanceOf(owner: ZswapCoinPublicKey): Uint<128> {
    if (!_balances.member(owner)) {
      return 0;
    }

    return _balances.lookup(owner);
  }

  /**
   * @description Returns the owner of the `tokenId` token.
   *
   * @param {TokenId} tokenId - The identifier for a token.
   * @return {Owner} - The public key that owns the token.
   */
  export circuit ownerOf(tokenId: Uint<128>): ZswapCoinPublicKey {
    return _requireOwned(tokenId);
  }

  /**
   * @description Returns the token URI for the given `tokenId`.
   *
   * @notice Since Midnight does not support native strings and string operations
   * within the Compact language, concatenating a base URI + token ID is not possible
   * like in other NFT implementations. Therefore, we propose the URI storage
   * approach; whereby, NFTs may or may not have unique "base" URIs.
   * It's up to the implementation to decide on how to handle this.
   *
   * @param {TokenId} tokenId - The identifier for a token.
   * @returns {Maybe<Opaque<"string">>} - the token id's URI.
   */
  export circuit tokenURI(tokenId: Uint<128>): Maybe<Opaque<"string">> {
    _requireOwned(tokenId);

    return _tokenURI.lookup(tokenId);
  }

  /**
   * @description Gives permission to `to` to transfer `tokenId` token to another account.
   * The approval is cleared when the token is transferred.
   *
   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
   *
   * Requirements:
   *
   * - The caller must own the token or be an approved operator.
   * - `tokenId` must exist.
   *
   * @param {ZswapCoinPublicKey} to - The account receiving the approval
   * @param {TokenId} tokenId - The token `to` may be permitted to transfer
   * @return {[]} - None.
   */
  export circuit approve(
    to: ZswapCoinPublicKey,
    tokenId: Uint<128>
  ): [] {
    const auth = own_public_key();
    _approve(
      to, 
      tokenId,
      auth
    );
  }

  /**
   * @description Returns the account approved for `tokenId` token.
   * 
   * @param {TokenId} tokenId - The token an account may be approved to manage
   * @return {Operator} - The account approved to manage the token
   */
  export circuit getApproved(tokenId: Uint<128>): ZswapCoinPublicKey {
    _requireOwned(tokenId);

    return _getApproved(tokenId);
  }

  /**
   * @description Approve or remove `operator` as an operator for the caller.
   * Operators can call {transferFrom} for any token owned by the caller.
   *
   * Requirements:
   *
   * - The `operator` cannot be the address zero.
   * 
   * @param {Operator} operator - An operator to manage the caller's tokens
   * @param {Boolean} approved - A boolean determining if `operator` may manage all tokens of the caller
   * @return {[]} - None.
   */
  export circuit setApprovalForAll(
    operator: ZswapCoinPublicKey,
    approved: Boolean
  ): [] {
    const owner = own_public_key();
    _setApprovalForAll(
      owner,
      operator,
      approved
    );
  }

  /**
   * @description Returns if the `operator` is allowed to manage all of the assets of `owner`.
   *
   * @param {Owner} owner - The owner of a token
   * @param {Operator} operator - An account that may operate on `owner`'s tokens
   * @return {Boolean} - A boolean determining if `operator` is allowed to manage all of the tokens of `owner` 
   */
  export circuit isApprovedForAll(
    owner: ZswapCoinPublicKey,
    operator: ZswapCoinPublicKey
  ): Boolean {
    if (_operatorApprovals.member(owner) && _operatorApprovals.lookup(owner).member(operator)) {
      return _operatorApprovals.lookup(owner).lookup(operator);
    } else {
      return false;
    }
  }

  /**
   * @description Transfers `tokenId` token from `from` to `to`.
   * 
   * Requirements:
   *
   * - `from` cannot be the zero address.
   * - `to` cannot be the zero address.
   * - `tokenId` token must be owned by `from`.
   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
   * 
   * @param {ZswapCoinPublicKey} from - The source account from which the token is being transfered
   * @param {ZswapCoinPublicKey} to - The target account to transfer token to
   * @param {TokenId} tokenId - The token being transfered
   * @return {[]} - None.
   */
  export circuit transferFrom(
    from: ZswapCoinPublicKey,
    to: ZswapCoinPublicKey,
    tokenId: Uint<128>
  ): [] {
    assert !Utils_isKeyZero(to) "ERC721: Invalid Receiver";
    // Setting an "auth" arguments enables the `_isAuthorized` check which verifies that the token exists
    // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.

    const previousOwner = _update(
      to,
      tokenId,
      own_public_key()
    );
    assert previousOwner == from "ERC721: Incorrect Owner";
  }

  /**
   * @description Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).
   * Returns the owner.
   *
   * Overrides to ownership logic should be done to {_ownerOf}.
   * 
   * @param {TokenId} tokenId - The token that should be owned
   * @return {Owner} - The owner of `tokenId`
   */
  export circuit _requireOwned(tokenId: Uint<128>): ZswapCoinPublicKey {
    const owner = _ownerOf(tokenId);

    assert !Utils_isKeyZero(owner) "ERC721: Nonexistent Token";
    return owner;
  }

  /**
   * @description Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist
   *
   * @param {TokenId} tokenId - The target token of the owner query
   * @return {Owner} - The owner of the token
   */
  export circuit _ownerOf(tokenId: Uint<128>): ZswapCoinPublicKey {
    if (!_owners.member(tokenId)) {
      _owners.insert(tokenId, default<ZswapCoinPublicKey>);
    }

    return _owners.lookup(tokenId);
  }

  /**
   * @description Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner
   * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.
   *
   * The `auth` argument is optional. If the value passed is non 0, then this function will check that
   * `auth` is either the owner of the token, or approved to operate on the token (by the owner).
   * 
   * @param {ZswapCoinPublicKey} to - The intended recipient of the token transfer
   * @param {TokenId} tokenId - The token being transfered
   * @param {ZswapCoinPublicKey} auth - An account authorized to transfer the token
   * @return {Owner} - Owner of the token before it was transfered
   */
  export circuit _update(
    to: ZswapCoinPublicKey,
    tokenId: Uint<128>,
    auth: ZswapCoinPublicKey
  ): ZswapCoinPublicKey {
    const from = _ownerOf(tokenId);

    // Perform (optional) operator check
    if (!Utils_isKeyZero(auth)) {
        _checkAuthorized(from, auth, tokenId);
    }

    // execute update
    if (!Utils_isKeyZero(from)) {
      _approve(default<ZswapCoinPublicKey>, tokenId, default<ZswapCoinPublicKey>);
      const newBalance = _balances.lookup(from) - 1 as Uint<128>;
      _balances.insert(from, newBalance);
    }

    if (!Utils_isKeyZero(to)) {
      if (!_balances.member(to)) {
        _balances.insert(to, 0);
      }
      const newBalance = _balances.lookup(to) + 1 as Uint<128>;
      _balances.insert(to, newBalance);
    }

    _owners.insert(tokenId, to);

    return from;
  }

  /**
   * @description  Approve `to` to operate on `tokenId`
   *
   * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is
   * either the owner of the token, or approved to operate on all tokens held by this owner.
   *
   * @param {ZswapCoinPublicKey} to - The target account to approve
   * @param {TokenId} tokenId - The token to approve
   * @param {ZswapCoinPublicKey} auth - An account authorized to operate on all tokens held by the owner the token
   * @return {[]} - None.
   */
  export circuit _approve(
    to: ZswapCoinPublicKey,
    tokenId: Uint<128>,
    auth: ZswapCoinPublicKey
  ): [] {
    if (!Utils_isKeyZero(auth)) {
      const owner = _requireOwned(tokenId);

      // We do not use _isAuthorized because single-token approvals should not be able to call approve
      assert (owner != auth && !isApprovedForAll(owner, auth)) "ERC721 Invalid Approver";
    }

    _tokenApprovals.insert(tokenId, to);
  }

  /**
   * @description Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.
   * Reverts if:
   * - `spender` does not have approval from `owner` for `tokenId`.
   * - `spender` does not have approval to manage all of `owner`'s assets.
   *
   * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this
   * assumption.
   *
   * @param {Owner} owner - Owner of the token
   * @param {ZswapCoinPublicKey} spender - Account operating on `tokenId`
   * @param {TokenId} tokenId - The token to spend
   * @return {[]} - None.
   */
  export circuit _checkAuthorized(
    owner: ZswapCoinPublicKey,
    spender: ZswapCoinPublicKey,
    tokenId: Uint<128>
  ): [] {
    if (!_isAuthorized(owner, spender, tokenId)) {
      assert !Utils_isKeyZero(owner) "ERC721: Nonexistent Token";
      assert false "ERC721: Insufficient Approval";
    }
  }

  /**
   * @description Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in
   * particular (ignoring whether it is owned by `owner`).
   *
   * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this
   * assumption.
   *
   * @param {Owner} owner - Owner of the token
   * @param {ZswapCoinPublicKey} spender - Account that wishes to spend `tokenId`
   * @param {TokenId} tokenId - Token to spend
   * @return {Boolean} - A boolean determining if `spender` may manage `tokenId`
   */
  export circuit _isAuthorized(
    owner: ZswapCoinPublicKey,
    spender: ZswapCoinPublicKey,
    tokenId: Uint<128>
  ): Boolean {
    return (!Utils_isKeyZero(spender) && (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender));
  }

  /**
   * @description Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.
   *
   * @param {TokenId} tokenId - The token to query
   * @return {ZswapCoinPublicKey} - An account approved to spend `tokenId`
   */
  export circuit _getApproved(tokenId: Uint<128>): ZswapCoinPublicKey {
    if (!_tokenApprovals.member(tokenId)) {
      return default<ZswapCoinPublicKey>;
    }
    return _tokenApprovals.lookup(tokenId);
  }

  /**
   * @description Approve `operator` to operate on all of `owner` tokens
   *
   * Requirements:
   * - operator can't be the address zero.
   *
   * @param {Owner} owner - Owner of a token
   * @param {Operator} operator - The account to approve
   * @param {Boolean} approved - A boolean determining if `operator` may operate on all of `owner` tokens 
   * @return {[]} - None.
   */
  export circuit _setApprovalForAll(
    owner: ZswapCoinPublicKey,
    operator: ZswapCoinPublicKey,
    approved: Boolean
  ): [] {
    assert !Utils_isKeyZero(operator) "ERC721: Invalid Operator";

    if (!_operatorApprovals.member(owner)) {
      _operatorApprovals.insert(
        owner,
        default<Map<ZswapCoinPublicKey, Boolean>>
      );
    }

    _operatorApprovals.lookup(owner).insert(operator, approved);
  }

  /**
   * @description Mints `tokenId` and transfers it to `to`.
   *
   * Requirements:
   *
   * - `tokenId` must not exist.
   * - `to` cannot be the zero address.
   * 
   * @param {ZswapCoinPublicKey} to - The account receiving `tokenId`
   * @param {TokenId} tokenId - The token to transfer
   * @return {[]} - None.
   */
  export circuit _mint(
    to: ZswapCoinPublicKey,
    tokenId: Uint<128>
  ): [] {
    assert !Utils_isKeyZero(to) "ERC721: Invalid Receiver";

    const previousOwner = _update(to, tokenId, default<ZswapCoinPublicKey>);

    assert Utils_isKeyZero(previousOwner) "ERC721: Invalid Sender";
  }

  /**
   * @description Destroys `tokenId`.
   * The approval is cleared when the token is burned.
   * This is an internal function that does not check if the sender is authorized to operate on the token.
   *
   * Requirements:
   *
   * - `tokenId` must exist.
   *
   * @param {TokenId} tokenId - The token to burn
   * @return {[]} - None.
   */
  export circuit _burn(tokenId: Uint<128>): [] {
    const previousOwner = _update(default<ZswapCoinPublicKey>, tokenId, default<ZswapCoinPublicKey>);
    assert !Utils_isKeyZero(previousOwner) "ERC721: Invalid Sender";
  }

  /**
   * @description Transfers `tokenId` from `from` to `to`.
   *  As opposed to {transferFrom}, this imposes no restrictions on own_public_key().
   *
   * Requirements:
   *
   * - `to` cannot be the zero address.
   * - `tokenId` token must be owned by `from`.
   *
   * @param {ZswapCoinPublicKey} from - The source account of the token transfer
   * @param {ZswapCoinPublicKey} to - The target account of the token transfer
   * @param {TokenId} tokenId - The token to transfer
   * @return {[]} - None.
   */
  export circuit _transfer(
    from: ZswapCoinPublicKey,
    to: ZswapCoinPublicKey,
    tokenId: Uint<128>
  ): [] {
    assert !Utils_isKeyZero(to) "ERC721: Invalid Receiver";

    const previousOwner = _update(to, tokenId, default<ZswapCoinPublicKey>);

    assert !Utils_isKeyZero(previousOwner) "ERC721: Nonexistent Token";
    assert previousOwner != from "ERC721: Incorrect Owner";
  }

  /**
   * @description Sets the the URI as `tokenURI` for the given `tokenId`.
   * The `tokenId` must exist.
   *
   * @notice The URI for a given NFT is usually set when the NFT is minted.
   *
   * @params {tokenId} - The identifier of the token.
   * @params {tokenURI} - The URI of `tokenId`.
   * @return {[]} - None.
   */
  export circuit _setTokenURI(tokenId: Uint<128>, tokenURI: Maybe<Opaque<"string">>): [] {
    _requireOwned(tokenId);

    return _tokenURI.insert(tokenId, tokenURI);
  }
}

