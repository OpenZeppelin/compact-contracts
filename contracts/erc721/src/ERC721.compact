// SPDX-License-Identifier: MIT

pragma language_version >= 0.14.0;

/**
 * @module ERC721
 * @description An unshielded ERC721 library.
 *
 * @notice ADD  
 *
 * @notice Further discussion and consideration required:
 *
 * - Consider changing the underscore in the internal methods to `unsafe` or
 * adopting dot notation for prefixing imports.
 * - Revise logic once contract-to-contract interactions are available on midnight.
 * - Consider implementing an introspection mechanism for transfers to contracts.
 * - Standardize which zero address to use (`ZswapCoinPublicKey` or `ContractAddress`).
 */
module ERC721 {
  import CompactStandardLibrary;
  import "../../node_modules/@openzeppelin-midnight/utils/src/Utils" prefix Utils_;

  /// Public state
  export sealed ledger _name: Maybe<Opaque<"string">>;
  export sealed ledger _symbol: Maybe<Opaque<"string">>;
  export ledger _owners: Map<Field, Either<ZswapCoinPublicKey, ContractAddress>>;
  export ledger _balances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>;
  export ledger _tokenApprovals: Map<Field, Either<ZswapCoinPublicKey, ContractAddress>>;
  export ledger _operatorApprovals: Map<Either<ZswapCoinPublicKey, ContractAddress>, Map<Either<ZswapCoinPublicKey, ContractAddress>, Boolean>>;

  /// Private state
  /**
    * @description Computes a tokenURI given a `baseURI` and `tokenId`
    * 
    * @param baseURI - baseURI of the final tokenURI, defaults to the empty string
    * @param tokenId - The token identifier
    *
    * @return {Opaque<"string">} - The final URI of the provided token identifier
    */
  witness computeTokenURI(baseURI: Opaque<"string">, tokenId: Field): Opaque<"string">;

  /**
    * @description Initializes the contract by setting the name and symbol.
    *
    * @param name_ - The name of the token.
    * @param symbol_ - The symbol of the token.
    */
  export circuit initializer(
    name_: Maybe<Opaque<"string">>,
    symbol_: Maybe<Opaque<"string">>
  ): [] {
    _name = name_;
    _symbol = symbol_;
  }

  /**
   * @description Returns the token name.
   *
   * @return {Maybe<Opaque<"string">>} - The token name.
   */
  export circuit name(): Maybe<Opaque<"string">> {
    return _name;
  }

  /**
   * @description Returns the symbol of the token.
   *
   * @return {Maybe<Opaque<"string">>} - The token name.
   */
  export circuit symbol(): Maybe<Opaque<"string">> {
    return _symbol;
  }


  /**
   * @description Returns the value of tokens owned by `account`.
   *
   * @dev Manually checks if `account` is a key in the map and returns 0 if it is not.
   *
   * @param {account} - The public key or contract address to query.
   * @return {Uint<128>} - The account's token balance.
   */
  export circuit balanceOf(account: Either<ZswapCoinPublicKey, ContractAddress>): Uint<128> {
    if (!_balances.member(account)) {
      return 0;
    }

    return _balances.lookup(account);
  }

  /**
   * @description Returns the owner of the `tokenId` token.
   *
   * @dev Tokens assigned to zero address are considered invalid, and queries about them do throw.
   *
   * @param {tokenId} - The identifier for a token.
   * @return {Either<ZswapCoinPublicKey, ContractAddress>} - The public key or contract that owns the token.
   */
  export circuit ownerOf(tokenId: Field): Either<ZswapCoinPublicKey, ContractAddress> {
    return _requireOwned(tokenId);
  }

  export circuit tokenURI(tokenId: Field): Opaque<"string"> {
    _requireOwned(tokenId);

    const baseURI = _baseURI();
    return disclose(computeTokenURI(baseURI, tokenId));
  }

  export circuit _baseURI(): Opaque<"string"> {
    return default<Opaque<"string">>;
  }

  export circuit approve(
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    tokenId: Field
  ): [] {
    // TMP - Waiting for contract-to-contract calls to handle `right` with contract address
    const auth = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
    _approve(
      to, 
      tokenId,
      auth
    );
  }

  export circuit getApproved(tokenId: Field): Either<ZswapCoinPublicKey, ContractAddress> {
    _requireOwned(tokenId);

    return _getApproved(tokenId);
  }

  export circuit setApprovalForAll(
    operator: Either<ZswapCoinPublicKey, ContractAddress>,
    approved: Boolean
  ): [] {
    // TMP - Waiting for contract-to-contract calls to handle `right` with contract address
    const owner = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
    _setApprovalForAll(
      owner,
      operator,
      approved
    );
  }

  export circuit isApprovedForAll(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    operator: Either<ZswapCoinPublicKey, ContractAddress>
  ): Boolean {
    if (_operatorApprovals.member(owner) && _operatorApprovals.lookup(owner).member(operator)) {
      return _operatorApprovals.lookup(owner).lookup(operator);
    } else {
      return false;
    }
  }

  export circuit transferFrom(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    tokenId: Field
  ): [] {
    assert !Utils_isKeyOrAddressZero(to) "ERC721: Invalid Receiver";
    // Setting an "auth" arguments enables the `_isAuthorized` check which verifies that the token exists
    // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.

    // Assumes sender is a ZSwapPublicKey
    // Need to revisit once we have contract <> contract communication
    const previousOwner = _update(
      to,
      tokenId,
      left<ZswapCoinPublicKey, ContractAddress>(own_public_key())
    );
    assert previousOwner != from "ERC721: Incorrect Owner";
  }

  export circuit safeTransferFrom(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    tokenId: Field
  ): [] {
    safeTransferFrom(from, to, tokenId, default<Opaque<"string">>);
  }

  export circuit safeTransferFrom(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    tokenId: Field,
    data: Opaque<"string">
  ): [] {
    transferFrom(from, to, tokenId);
    // See https://github.com/OpenZeppelin/midnight-contracts/issues/25
    // ERC721Utils_checkOnERC721Received
  }

  export circuit _requireOwned(tokenId: Field): Either<ZswapCoinPublicKey, ContractAddress> {
    assert _owners.member(tokenId) "ERC721: Nonexistent Token";
    const owner = _owners.lookup(tokenId);

    assert !Utils_isKeyOrAddressZero(owner) "ERC721: Invalid Owner";
    return owner;
  }

  export circuit _ownerOf(tokenId: Field): Either<ZswapCoinPublicKey, ContractAddress> {
    return _owners.lookup(tokenId);
  }

  export circuit _update(
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    tokenId: Field,
    auth: Either<ZswapCoinPublicKey, ContractAddress>
  ): Either<ZswapCoinPublicKey, ContractAddress> {
    const from = _ownerOf(tokenId);

    // Perform (optional) operator check
    if (!Utils_isKeyOrAddressZero(auth)) {
        _checkAuthorized(from, auth, tokenId);
    }

    // execute update
    if (!Utils_isKeyOrAddressZero(from)) {
      // assuming burn address == zero address
      // Need to test to confirm
      _approve(burn_address(), tokenId, burn_address());
      const newBalance = _balances.lookup(from) - 1 as Uint<128>;
      _balances.insert(from, newBalance);
    }

    if (!Utils_isKeyOrAddressZero(to)) {
      const newBalance = _balances.lookup(to) + 1 as Uint<128>;
      _balances.insert(to, newBalance); 
    }

    _owners.insert(tokenId, to);

    return from;
  }

  export circuit _approve(
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    tokenId: Field,
    auth: Either<ZswapCoinPublicKey, ContractAddress>
  ): [] {
    if (!Utils_isKeyOrAddressZero(auth)) {
      const owner = _requireOwned(tokenId);

      // We do not use _isAuthorized because single-token approvals should not be able to call approve
      assert (!Utils_isKeyOrAddressZero(auth) && owner != auth && !isApprovedForAll(owner, auth)) "ERC721 Invalid Approver";
    }

    _tokenApprovals.insert(tokenId, to);
  }

  export circuit _checkAuthorized(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    spender: Either<ZswapCoinPublicKey, ContractAddress>,
    tokenId: Field
  ): [] {
    if (!_isAuthorized(owner, spender, tokenId)) {
      assert !Utils_isKeyOrAddressZero(owner) "ERC721: Nonexistent Token";
      assert false "ERC721: Insufficient Approval";
    }
  }

  export circuit _isAuthorized(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    spender: Either<ZswapCoinPublicKey, ContractAddress>,
    tokenId: Field
  ): Boolean {
    return (!Utils_isKeyOrAddressZero(spender) && (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender));
  }

  export circuit _getApproved(tokenId: Field): Either<ZswapCoinPublicKey, ContractAddress> {
    // I think this returns the 0 address if token doesn't exist
    // Make sure this doesn't cause problem in testing
    return _tokenApprovals.lookup(tokenId);
  }

  export circuit _setApprovalForAll(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    operator: Either<ZswapCoinPublicKey, ContractAddress>,
    approved: Boolean
  ): [] {
    assert !Utils_isKeyOrAddressZero(operator) "ERC721: Invalid Operator";

    if (!_operatorApprovals.member(owner)) {
      _operatorApprovals.insert(
        owner, 
        default<Map<Either<ZswapCoinPublicKey, ContractAddress>, Boolean>>
      );
      _operatorApprovals.lookup(owner).insert(operator, approved);
    } else {
      _operatorApprovals.lookup(owner).insert(operator, approved);
    }
  }
  
  export circuit _increaseBalance(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): [] {
    const newValue = _balances.lookup(account) + value;
    _balances.insert(account, newValue as Uint<128>);
  }

  export circuit _mint(
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    tokenId: Field 
  ): [] {
    assert !Utils_isKeyOrAddressZero(to) "ERC721: Invald Receiver";

    // Assumes burn_address == zero address 
    // May want to define as default<ContractAddress>
    const previousOwner = _update(to, tokenId, burn_address());

    assert !Utils_isKeyOrAddressZero(previousOwner) "ERC721: Invalid Sender";
  }

  export circuit _safeMint(
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    tokenId: Field  
  ): [] {
    _safeMint(to, tokenId, default<Opaque<"string">>);
  }

  export circuit _safeMint(
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    tokenId: Field,
    data: Opaque<"string">
  ): [] {
    _mint(to, tokenId);
    // ERC721Utils_checkOnERC721Received
  }

  export circuit _burn(tokenId: Field): [] {
    const previousOwner = _update(burn_address(), tokenId, burn_address());
    assert !Utils_isKeyOrAddressZero(previousOwner) "ERC721: Nonexistent Token";
  }

  export circuit _transfer(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    tokenId: Field
  ): [] {
    assert !Utils_isKeyOrAddressZero(to) "ERC721: Invalid Receiver";

    const previousOwner = _update(to, tokenId, burn_address());

    assert !Utils_isKeyOrAddressZero(previousOwner) "ERC721: Nonexistent Token";
    assert previousOwner != from "ERC721: Incorrect Owner";
  }
}

