pragma language_version >= 0.15.0;

import CompactStandardLibrary;

import "../../ERC721" prefix ERC721_;

export { ZswapCoinPublicKey, ContractAddress, Either, Maybe };

export circuit name(): Opaque<"string"> {
  return ERC721_name();
}

export circuit symbol(): Opaque<"string"> {
  return ERC721_symbol();
}

export circuit balanceOf(account: Either<ZswapCoinPublicKey, ContractAddress>): Uint<128> {
  return ERC721_balanceOf(account);
}

export circuit ownerOf(tokenId: Uint<128>): Either<ZswapCoinPublicKey, ContractAddress> {
  return ERC721_ownerOf(tokenId);
}

export circuit tokenURI(tokenId: Uint<128>): Opaque<"string"> {
  return ERC721_tokenURI(tokenId);
}

export circuit approve(
  to: Either<ZswapCoinPublicKey, ContractAddress>,
  tokenId: Uint<128>
): [] {
  return ERC721_approve(to, tokenId);
}

export circuit getApproved(tokenId: Uint<128>): Either<ZswapCoinPublicKey, ContractAddress> {
  return ERC721_getApproved(tokenId);
}

export circuit setApprovalForAll(
  operator: Either<ZswapCoinPublicKey, ContractAddress>,
  approved: Boolean
): [] {
  return ERC721_setApprovalForAll(operator, approved);
}

export circuit isApprovedForAll(
  owner: Either<ZswapCoinPublicKey, ContractAddress>,
  operator: Either<ZswapCoinPublicKey, ContractAddress>
): Boolean {
  return ERC721_isApprovedForAll(owner, operator);
}

export circuit transferFrom(
  from: Either<ZswapCoinPublicKey, ContractAddress>,
  to: Either<ZswapCoinPublicKey, ContractAddress>,
  tokenId: Uint<128>
): [] {
  return ERC721_transferFrom(from, to, tokenId);
}

export circuit _requireOwned(tokenId: Uint<128>): Either<ZswapCoinPublicKey, ContractAddress> {
  return ERC721__requireOwned(tokenId);
}

export circuit _ownerOf(tokenId: Uint<128>): Either<ZswapCoinPublicKey, ContractAddress> {
  return ERC721__ownerOf(tokenId);
}

export circuit _update(
  to: Either<ZswapCoinPublicKey, ContractAddress>,
  tokenId: Uint<128>,
  auth: Either<ZswapCoinPublicKey, ContractAddress>
): Either<ZswapCoinPublicKey, ContractAddress> {
  return ERC721__update(to, tokenId, auth);
}

export circuit _approve(
  to: Either<ZswapCoinPublicKey, ContractAddress>,
  tokenId: Uint<128>,
  auth: Either<ZswapCoinPublicKey, ContractAddress>
): [] {
  return ERC721__approve(to, tokenId, auth);
}

export circuit _checkAuthorized(
  owner: Either<ZswapCoinPublicKey, ContractAddress>,
  spender: Either<ZswapCoinPublicKey, ContractAddress>,
  tokenId: Uint<128>
): [] {
  return ERC721__checkAuthorized(owner, spender, tokenId);
}

export circuit _isAuthorized(
  owner: Either<ZswapCoinPublicKey, ContractAddress>,
  spender: Either<ZswapCoinPublicKey, ContractAddress>,
  tokenId: Uint<128>
): Boolean {
  return ERC721__isAuthorized(owner, spender, tokenId);
}

export circuit _getApproved(tokenId: Uint<128>): Either<ZswapCoinPublicKey, ContractAddress> {
  return ERC721__getApproved(tokenId);
}

export circuit _setApprovalForAll(
  owner: Either<ZswapCoinPublicKey, ContractAddress>,
  operator: Either<ZswapCoinPublicKey, ContractAddress>,
  approved: Boolean
): [] {
  return ERC721__setApprovalForAll(owner, operator, approved);
}

export circuit _mint(
  to: Either<ZswapCoinPublicKey, ContractAddress>,
  tokenId: Uint<128>
): [] {
  return ERC721__mint(to, tokenId);
}

export circuit _burn(tokenId: Uint<128>): [] {
  return ERC721__burn(tokenId);
}

export circuit _transfer(
  from: Either<ZswapCoinPublicKey, ContractAddress>,
  to: Either<ZswapCoinPublicKey, ContractAddress>,
  tokenId: Uint<128>
): [] {
  return ERC721__transfer(from, to, tokenId);
}

export circuit _setTokenURI(tokenId: Uint<128>, tokenURI: Opaque<"string">): [] {
  return ERC721__setTokenURI(tokenId, tokenURI);
}

export circuit _unsafeTransferFrom(
  from: Either<ZswapCoinPublicKey, ContractAddress>,
  to: Either<ZswapCoinPublicKey, ContractAddress>,
  tokenId: Uint<128>
): [] {
  return ERC721__unsafeTransferFrom(from, to, tokenId);
}

export circuit _unsafe_transfer(
  from: Either<ZswapCoinPublicKey, ContractAddress>,
  to: Either<ZswapCoinPublicKey, ContractAddress>,
  tokenId: Uint<128>
): [] {
  return ERC721__unsafe_transfer(from, to, tokenId); 
}

export circuit _unsafe_mint(
  to: Either<ZswapCoinPublicKey, ContractAddress>,
  tokenId: Uint<128>
): [] {
  return ERC721__unsafe_mint(to, tokenId);  
}
