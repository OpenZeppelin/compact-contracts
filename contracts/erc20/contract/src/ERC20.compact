// SPDX-License-Identifier: MIT

pragma language_version >= 0.14.0;

module ERC20 {
  import CompactStandardLibrary;

  /// Public state
  export ledger _name: Maybe<Opaque<"string">>;
  export ledger _symbol: Maybe<Opaque<"string">>;
  export ledger _decimals: Uint<8>;
  export ledger _totalSupply: Uint<128>;
  export ledger _balances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>;
  export ledger _allowances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>>;

  /**
   * @description Initializes the contract by setting the name, symbol, and decimals.
   *
   * @param name_ - The name of the token.
   * @param symbol_ - The symbol of the token.
   * @param decimals_ - The number of decimals used to get the user representation.
   */
  export circuit initializer(
    name_: Maybe<Opaque<"string">>,
    symbol_: Maybe<Opaque<"string">>,
    decimals_:Uint<8>
  ): [] {
    _name = name_;
    _symbol = symbol_;
    _decimals = decimals_;
  }

  /**
   * @description Returns the token name.
   *
   * @return {Maybe<Opaque<"string">>} - The token name.
   */
  export circuit name(): Maybe<Opaque<"string">> {
    return _name;
  }

  /**
   * @description Returns the symbol of the token.
   *
   * @return {Maybe<Opaque<"string">>} - The token name.
   */
  export circuit symbol(): Maybe<Opaque<"string">> {
    return _symbol;
  }

  /**
   * @description Returns the number of decimals used to get its user representation.
   *
   * @return {Uint<8>} - The account's token balance.
   */
  export circuit decimals(): Uint<8> {
    return _decimals;
  }

  /**
   * @description Returns the value of tokens in existence.
   *
   * @return {Uint<128>} - The total supply of tokens.
   */
  export circuit totalSupply(): Uint<128> {
    return _totalSupply;
  }

  /**
   * @description Returns the value of tokens owned by `account`.
   *
   * @dev Manually checks if `account` is a key in the map and returns 0 if it is not.
   *
   * @param {account} - The public key or contract address to query.
   * @return {Uint<128>} - The account's token balance.
   */
  export circuit balanceOf(account: Either<ZswapCoinPublicKey, ContractAddress>): Uint<128> {
    if (!_balances.member(account)) {
      return 0;
    }

    return _balances.lookup(account);
  }

  /**
   * @description Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner`
   *              through `transferFrom`. This value changes when `approve` or `transferFrom` are called.
   *
   * @dev Manually checks if `owner` and `spender` are keys in the map and returns 0 if they are not.
   *
   * @param {owner} - The public key or contract address of approver.
   * @param {spender} - The public key or contract address of spender.
   * @return {Uint<128>} - The `spender`'s allowance over `owner`'s tokens.
   */
  export circuit allowance(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    spender: Either<ZswapCoinPublicKey, ContractAddress>
  ): Uint<128> {
    if (!_allowances.member(owner) || !_allowances.lookup(owner).member(spender)) {
      return 0;
    }

    return _allowances.lookup(owner).lookup(spender);
  }

  /**
   * @description Moves a `value` amount of tokens from the caller's account to `to`.
   *
   * @dev We need to get the caller address from contracts and handle the transfer appropriately.
   *      This should include a callback to ensure the contract can safely receive tokens.
   *
   * @param {to} - The recipient of the transfer, either a user or a contract.
   * @param {value} - The amount to transfer.
   * @return {Boolean} - As per the IERC20 spec, this MUST return true.
   */
  export circuit transfer(to: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>): Boolean {
    // TMP - Waiting for contract-to-contract calls to handle `right` with contract address
    const owner = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
    _transfer(owner, to, value);
    return true;
  }

  /**
   * @description Moves `value` tokens from `from` to `to` using the allowance mechanism.
   * `value` is the deducted from the caller's allowance.
   *
   * @dev We need to get the caller address from contracts and handle the transfer appropriately.
   *      This should include a callback to ensure the contract can safely receive tokens.
   *
   * @param {from} - The current owner of the tokens for the transfer, either a user or a contract.
   * @param {to} - The recipient of the transfer, either a user or a contract.
   * @param {value} - The amount to transfer.
   * @return {Boolean} - As per the IERC20 spec, this MUST return true.
   */
  export circuit transferFrom(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): Boolean {
    // TMP - Waiting for contract-to-contract calls to handle `right` with contract address
    const spender = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
    _spendAllowance(from, spender, value);
    _transfer(from, to, value);
    return true;
  }

  /**
   * @description Sets a `value` amount of tokens as allowance of `spender` over the caller's tokens.
   *
   * @param {spender} - The Zswap key or ContractAddress that may spend on behalf of the caller.
   * @param {value} - The amount of tokens the `spender` may spend.
   * @return {Boolean} - Returns a boolean value indicating whether the operation succeeded.
   */
  export circuit approve(spender: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>): Boolean {
    // TMP - Waiting for contract-to-contract calls to handle `right` with contract address
    const owner = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
    _approve(owner, spender, value);
    return true;
  }

  /**
   * @description Sets `value` as the allowance of `spender` over the `owner`'s tokens.
   * This internal function is equivalent to `approve`, and can be used to
   * e.g. set automatic allowances for certain subsystems, etc.
   *
   * @param {owner} - The owner of the tokens.
   * @param {spender} - The spender of the tokens.
   * @param {value} - The amount of tokens `spender` may spend on behalf of `owner`.
   * @return {[]} - None.
   */
  export circuit _approve(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    spender: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): [] {
    assert !isZero(owner) "ERC20: invalid owner";
    assert !isZero(spender) "ERC20: invalid spender";
    if (!_allowances.member(owner)) {
      // If owner doesn't exist, create and insert a new sub-map directly
      _allowances.insert(owner, default<Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>>);
    }
    _allowances.lookup(owner).insert(spender, value);
  }

  /**
   * @description Moves a `value` amount of tokens from `from` to `to`.
   * This internal function is equivalent to {transfer}, and can be used to
   * e.g. implement automatic token fees, slashing mechanisms, etc.
   *
   * @param {from} - The owner of the tokens to transfer.
   * @param {to} - The receipient of the transferred tokens.
   * @param {value} - The amount of tokens to transfer.
   * @return {[]} - None.
   */
  export circuit _transfer(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): [] {
    assert !isZero(from) "ERC20: invalid sender";
    assert !isZero(to) "ERC20: invalid receiver";

    _update(from, to, value);
  }

  /**
   * @description Creates a `value` amount of tokens and assigns them to `account`,
   * by transferring it from the zero address. Relies on the `update` mechanism.
   *
   * @param {account} - The recipient of tokens minted.
   * @param {value} - The amount of tokens minted.
   * @return {[]} - None.
   */
  export circuit _mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): [] {
    assert !isZero(account) "ERC20: invalid receiver";
    // Using the contract variant of 0
    // TODO: Look into if this matters
    const zero_address = right<ZswapCoinPublicKey, ContractAddress>(ContractAddress{ pad(32, "") });

    _update(zero_address, account, value);
  }

  /**
   * @description Destroys a `value` amount of tokens from `account`, lowering the total supply.
   * Relies on the `_update` mechanism.
   *
   * @param {account} - The target owner of tokens to burn.
   * @param {value} - The amount of tokens to burn.
   * @return {[]} - None.
   */
  export circuit _burn(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): [] {
    assert !isZero(account) "ERC20: invalid sender";
    // Using the contract variant of 0
    // TODO: Look into if this matters
    const zero_address = right<ZswapCoinPublicKey, ContractAddress>(ContractAddress{ pad(32, "") });
    _update(account, zero_address, value);
  }

  /**
   * @description Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`
   * (or `to`) is the zero address.
   *
   * @param {from} - The original owner of the tokens moved (which is 0 if tokens are minted).
   * @param {to} - The recipient of the tokens moved (which is 0 if tokens are burned).
   * @param {value} - The amount of tokens moved from `from` to `to`.
   * @return {[]} - None.
   */
  export circuit _update(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): [] {
    if (isZero(from)) {
      // Mint
      _totalSupply = _totalSupply + value as Uint<128>;
    } else {
      const fromBal = balanceOf(from);
      assert fromBal >= value "ERC20: insufficient balance";
      _balances.insert(from, fromBal - value as Uint<128>);
    }

    if (isZero(to)) {
      // Burn
      _totalSupply = _totalSupply - value as Uint<128>;
    } else {
      const toBal = balanceOf(to);
          _balances.insert(to, toBal + value as Uint<128>);
    }
  }

  /**
   * @description Updates `owner`'s allowance for `spender` based on spent `value`.
   * Does not update the allowance value in case of infinite allowance.
   *
   * @param {owner} - The owner of the tokens.
   * @param {spender} - The spender of the tokens.
   * @param {value} - The amount of token allowance to spend.
   * @return {[]} - None.
   */
  export circuit _spendAllowance(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    spender: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): [] {
    // TODO: Look into improving design so we're not checking allowance member twice (here and in `_approve`)
    assert (_allowances.member(owner) && _allowances.lookup(owner).member(spender)) "ERC20: insufficient allowance";

    const currentAllowance = _allowances.lookup(owner).lookup(spender);
    // TODO: improve readability of max_u128
    const max_u128 = 340282366920938463463374607431768211455;
    if (currentAllowance < max_u128) {
      assert currentAllowance >= value "ERC20: insufficient allowance";
      _approve(owner, spender, currentAllowance - value as Uint<128>);
    }
  }

  /**
   * @description Returns whether `keyOrAddress` is the zero address.
   * @todo Move to a utils contract since this will likely be reused.
   *
   * @param {keyOrAddress} - The target value to check, either a ZswapCoinPublicKey or a ContractAddress.
   * @return {Boolean} - Returns true if `keyOrAddress` is zero.
   */
  export pure circuit isZero(keyOrAddress: Either<ZswapCoinPublicKey, ContractAddress>): Boolean {
    const zero = pad(32, "");

    if (keyOrAddress.is_left) {
      return keyOrAddress == left<ZswapCoinPublicKey, ContractAddress>(ZswapCoinPublicKey{ zero });
    } else {
      return keyOrAddress == right<ZswapCoinPublicKey, ContractAddress>(ContractAddress{ zero });
    }
  }
}
