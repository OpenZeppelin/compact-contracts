// SPDX-License-Identifier: MIT

pragma language_version >= 0.15.0;

import CompactStandardLibrary;

import "../../Ownable" prefix Ownable_;

export { ZswapCoinPublicKey, ContractAddress, Either, Maybe };

/**
 * @description `isUnsafeOwner` and `isInit` are params for testing.
 *
 * If `isUnsafeOwner` is true, the initial owner may be a
 * ContractAddress type through invoking `_unsafeInitialize`.
 * Otherwise, the contract will call regular `initialize` which
 * disallows ownership to contract addresses.
 *
 * If `isInit` is false, the constructor will not initialize the contract.
 * This behavior is to test that circuits are not callable unless the
 * contract is initialized.
*/
constructor(initialOwner: Either<ZswapCoinPublicKey, ContractAddress>, isUnsafeOwner: Boolean, isInit: Boolean) {
  if (isInit) {
    if (isUnsafeOwner) {
      Ownable__unsafeInitialize(initialOwner);
    } else {
      Ownable_initialize(initialOwner);
    }
  }
}

export circuit owner(): Either<ZswapCoinPublicKey, ContractAddress> {
  return Ownable_owner();
}

export circuit transferOwnership(newOwner: Either<ZswapCoinPublicKey, ContractAddress>): [] {
  return Ownable_transferOwnership(newOwner);
}

export circuit _unsafeTransferOwnership(newOwner: Either<ZswapCoinPublicKey, ContractAddress>): [] {
  return Ownable__unsafeTransferOwnership(newOwner);
}

export circuit renounceOwnership(): [] {
  return Ownable_renounceOwnership();
}

export circuit _assertOnlyOwner(): [] {
  return Ownable__assertOnlyOwner();
}

export circuit _transferOwnership(newOwner: Either<ZswapCoinPublicKey, ContractAddress>): [] {
  return Ownable__transferOwnership(newOwner);
}

export circuit _unsafeUncheckedTransferOwnership(newOwner: Either<ZswapCoinPublicKey, ContractAddress>): [] {
  return Ownable__unsafeUncheckedTransferOwnership(newOwner);
}
