// SPDX-License-Identifier: MIT

pragma language_version >= 0.15.0;

import CompactStandardLibrary;

import "../../Ownable" prefix Ownable_;

export { ZswapCoinPublicKey, ContractAddress, Either, Maybe };

/**
 * @description `isUnsafeOwner` is a param for testing.
 * If `isUnsafeOwner` is true, the initial owner may be a
 * ContractAddress type through invoking `_unsafeInitialize`.
 * Otherwise, the contract call regular `initialize` which
 * disallows ownership to contract addresses.
*/
constructor(initialOwner: Either<ZswapCoinPublicKey, ContractAddress>, isUnsafeOwner: Boolean) {
  if (isUnsafeOwner) {
    Ownable__unsafeInitialize(initialOwner);
  } else {
    Ownable_initialize(initialOwner);
  }
}

export circuit owner(): Either<ZswapCoinPublicKey, ContractAddress> {
  return Ownable_owner();
}

export circuit pendingOwner(): Either<ZswapCoinPublicKey, ContractAddress> {
  return Ownable_pendingOwner();
}

export circuit assertOnlyOwner(): [] {
  return Ownable_assertOnlyOwner();
}

export circuit transferOwnership(newOwner: Either<ZswapCoinPublicKey, ContractAddress>): [] {
  return Ownable_transferOwnership(newOwner);
}

export circuit acceptOwnership(): [] {
  return Ownable_acceptOwnership();
}

export circuit renounceOwnership(): [] {
  return Ownable_renounceOwnership();
}

export circuit _transferOwnership(newOwner: Either<ZswapCoinPublicKey, ContractAddress>): [] {
  return Ownable__transferOwnership(newOwner);
}

export circuit _proposeOwner(newOwner: Either<ZswapCoinPublicKey, ContractAddress>): [] {
  return Ownable__proposeOwner(newOwner);
}
