// SPDX-License-Identifier: MIT

pragma language_version >= 0.15.0;

/**
 * @module Ownable
 * @description An unshielded Ownable library.
 * This modules provides a basic access controlmechanism, where there is an owner
 * that can be granted exclusive access to specific circuits.
 *
 * The initial owner must be set by using the `initialize` circuit during construction.
 * This can later be changed with `transferOwnership`.
 *
 * @notice Ownership can only be transferred to ZSwapCoinPublicKeys
 * through the main transfer circuits (`transferOwnership` and `_transferOwnership`).
 * In other words, ownership transfers to contract addresses are disallowed through these
 * circuits.
 * This is because Compact currently does not support contract-to-contract calls which means
 * if a contract is granted ownership, the owner contract cannot directly call the protected
 * circuit.
 *
 * @notice This module does offer experimental circuits that allow ownership to be granted
 * to contract addresses (`_unsafeTransferOwnshiper` and `_unsafeUncheckedTransferOwnership`).
 * Note that the circuit names are very explicit ("unsafe").
 * Transferring ownership to a contract address is the equivalent to renouncing ownership up until
 * contract-to-contract calls are supported.
 *
 * @notice The unsafe circuits are planned to become deprecated once contract-to-contract calls
 * are supported.
 */
module Ownable {
  import CompactStandardLibrary;
  import "../../node_modules/@openzeppelin-midnight/utils/src/Utils" prefix Utils_;
  import "../../node_modules/@openzeppelin-midnight/utils/src/Initializable" prefix Initializable_;

  export ledger _owner: Either<ZswapCoinPublicKey, ContractAddress>;

  /**
   * @description Initializes the contract by setting the `initialOwner`.
   *
   * @warning Contracts must only use either `initialize` or `_unsafeInitialize`—never both.
   * `_unsafeInitialize` allows the initial owner to be a ContractAddress type.
   * Contract-to-contract calls are currently not supported; therefore,
   * contracts have no way of calling a protected circuit.
   *
   * Requirements:
   *
   * - Contract is not already initialized.
   * - `initialOwner` is not a ContractAddress.
   * - `initialOwner` is not the zero address.
   *
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} initialOwner - The initial owner of the contract.
   * @returns {[]} Empty tuple.
   */
  export circuit initialize(initialOwner: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    assert !Utils_isContractAddress(initialOwner) "Ownable: unsafe initial owner";
    _unsafeInitialize(initialOwner);
  }

  /**
   * @description Unsafe variant of `initialize`.
   * This circuit is for experimental purposes in order to allow the `initialOwner`
   * to be a ContractAddress type.
   *
   * @warning Contracts must only use either `initialize` or `_unsafeInitialize`—never both.
   * `_unsafeInitialize` allows the initial owner to be a ContractAddress type.
   * Contract-to-contract calls are currently not supported; therefore,
   * contracts have no way of calling a protected circuit.
   *
   * Requirements:
   *
   * - Contract is not already initialized.
   * - `initialOwner` is not the zero address.
   *
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} initialOwner - The initial owner of the contract.
   * @returns {[]} Empty tuple.
   */
  export circuit _unsafeInitialize(initialOwner: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    Initializable_initialize();
    _unsafeTransferOwnership(initialOwner);
  }

  /**
   * @description Returns public key or contract address of the current owner.
   *
   * Requirements:
   *
   * - Contract is initialized.
   *
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} initialOwner - The initial owner of the contract.
   * @returns {Either<ZswapCoinPublicKey, ContractAddress> } - The contract owner.
   */
  export circuit owner(): Either<ZswapCoinPublicKey, ContractAddress> {
    Initializable_assertInitialized();
    return _owner;
  }

  /**
   * @description Transfers ownership of the contract to a owner.
   *
   * @notice Ownership transfers to contract addresses are currently disallowed until contract-to-contract
   * interactions are supported in Compact.
   * This restriction prevents circuits from being inadvertently locked in contracts.
   *
   * Requirements:
   *
   * - Contract is initialized.
   * - The caller is the current contract owner.
   * - `newOwner` is not a ContractAddress.
   * - `newOwner` is not the zero address.
   *
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} initialOwner - The new owner.
   * @returns {[]} Empty tuple.
   */
  export circuit transferOwnership(newOwner: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    Initializable_assertInitialized();
    assert !Utils_isContractAddress(newOwner) "Ownable: unsafe ownership transfer";
    _unsafeTransferOwnership(newOwner);
  }

  /**
   * @description Unsafe variant of `transferOwnership`.
   *
   * @warning Ownership transfers to contract addresses are considered unsafe because contract-to-contract
   * calls are not currently supported.
   * Ownership privileges sent to a contract address may become uncallable.
   * Once contract-to-contract calls are supported, this circuit may be deprecated.
   *
   * Requirements:
   *
   * - Contract is initialized.
   * - The caller is the current contract owner.
   * - `newOwner` is not the zero address.
   *
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} initialOwner - The new owner.
   * @returns {[]} Empty tuple.
   */
  export circuit _unsafeTransferOwnership(newOwner: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    Initializable_assertInitialized();
    _assertOnlyOwner();
    assert !Utils_isKeyOrAddressZero(newOwner) "Ownable: invalid new owner";
    _unsafeUncheckedTransferOwnership(newOwner);
  }

  /**
   * @description Leaves the contract without an owner.
   * It will not be possible to call `assertOnlyOnwer` circuits anymore.
   * Can only be called by the current owner.
   *
   * Requirements:
   *
   * - Contract is initialized.
   * - The caller is the current contract owner.
   *
   * @returns {[]} Empty tuple.
   */
  export circuit renounceOwnership(): [] {
    Initializable_assertInitialized();
    _assertOnlyOwner();
    _transferOwnership(burn_address());
  }

  /**
   * @description Throws if called by any account other than the owner.
   * Use this to restrict access of specific circuits to the owner.
   *
   * Requirements:
   *
   * - Contract is initialized.
   * - The caller is the current contract owner.
   *
   * @returns {[]} Empty tuple.
   */
  export circuit _assertOnlyOwner(): [] {
    Initializable_assertInitialized();
    const caller = own_public_key();
    assert caller == _owner.left "Ownable: caller is not the owner";
  }

  /**
   * @description Transfers ownership of the contract to a new owner without
   * enforcing permission checks on the caller.
   *
   * @notice Ownership transfers to contract addresses are currently disallowed until contract-to-contract
   * interactions are supported in Compact.
   * This restriction prevents circuits from being inadvertently locked in contracts.
   *
   * Requirements:
   *
   * - Contract is initialized.
   * - `newOwner` is not a ContractAddress.
   * - `newOwner` is not the zero address.
   *
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} initialOwner - The new owner.
   * @returns {[]} Empty tuple.
   */
  export circuit _transferOwnership(newOwner: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    Initializable_assertInitialized();
    assert !Utils_isContractAddress(newOwner) "Ownable: unsafe ownership transfer";
    _unsafeUncheckedTransferOwnership(newOwner);
  }

  /**
   * @description Unsafe variant of `_transferOwnership`.
   *
   * @warning Ownership transfers to contract addresses are considered unsafe because contract-to-contract
   * calls are not currently supported.
   * Ownership privileges sent to a contract address may become uncallable.
   * Once contract-to-contract calls are supported, this circuit may be deprecated.
   *
   * Requirements:
   *
   * - Contract is initialized.
   * - `newOwner` is not the zero address.
   *
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} initialOwner - The new owner.
   * @returns {[]} Empty tuple.
   */
  export circuit _unsafeUncheckedTransferOwnership(newOwner: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    Initializable_assertInitialized();
    _owner = newOwner;
  }
}
