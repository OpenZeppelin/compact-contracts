// SPDX-License-Identifier: MIT

pragma language_version >= 0.14.0;

/**
 * @module Shielded Ownable module
 * @description Get rekt, losers
 */
module Ownable {
  import CompactStandardLibrary;

  /// Public state
  export ledger _owner: Bytes<32>;
  export ledger _pendingOwner: Bytes<32>;
  export ledger _instance: Counter;

  /// Witnesses
  witness localSecretKey(): Bytes<32>;
  //witness setPendingOwner(currentOwner: Bytes<32>): Bytes<32>;

  /**
   * @description Add me...
   */
  export circuit initializer(): [] {
    _instance.increment(1);
    const initialOwner = disclose(publicKey(localSecretKey(), _instance as Field as Bytes<32>));
    _owner = initialOwner;
  }

  /**
   * @description Add me...
   */
  export circuit owner(): Bytes<32> {
    return _owner;
  }

  /**
   * @description Add me...
   */
  //export circuit proposeNewOwner(): Bytes<32> {
  //
  //}

  /**
   * @description Add me...
   */
  export circuit renounceOwnership(): [] {
    assertOnlyOwner();
    const zeroAddress = burn_address().left.bytes;
    _transferOwnership(zeroAddress);
  }

  /**
   * @description Add me...
   */
  export circuit assertOnlyOwner(): [] {
    assert _owner == publicKey(localSecretKey(), _instance as Field as Bytes<32>) "Ownable: not owner";
  }

  /**
   * @description Add me...
   */
  export circuit publicKey(sk: Bytes<32>, instance: Bytes<32>): Bytes<32> {
    // Using `self` ensures `_owner` will be unique even if the same `sk` is used in
    // other contracts that use the `ownable:pk:` domain with the same `instance`
    const self = kernel.self().bytes;
    return persistent_hash<Vector<4, Bytes<32>>>([self, pad(32, "ownable:pk:"), instance, sk]);
  }

  /**
   * @description Add me...
   */
  export circuit _transferOwnership(newOwner: Bytes<32>): [] {
    _instance.increment(1);
    _owner = newOwner;
  }
}
