// SPDX-License-Identifier: MIT

pragma language_version >= 0.16.0;

/**
 * @module ZOwnablePK
 * @description A shielded, public key-derived Ownable module.
 *
 * `ZOwnablePK` provides a privacy-preserving access control mechanism
 * for contracts with a single administrative user. Unlike traditional
 * `Ownable` implementations that store or expose the owner's public key
 * on-chain, this module stores only a commitment to a hashed identifier
 * derived from the owner's public key and a secret nonce.
 *
 * @notice This module explicitly supports commitments derived from public keys;
 * however, it may be possible to use contract addresses when contract-to-contract
 * calls become available. This will be revisited when it is know if/how witnesses
 * are used from a contract address context.
 *
 * @dev Features:
 * - Obfuscated owner identity: The owner's public key is never revealed on-chain.
 * - Stateless verification: The contract never needs access to the full public key.
 * - Built-in support for transfer and renounce functionality.
 * - Instance-specific salts to prevent cross-contract correlation.
 * - Deterministic hashing with `persistentHash` to support zero-knowledge verification.
 *
 * @dev Commitment structure:
 * ```
 * id = H(pk, secretNonce)
 * commitment = H(id, instanceSalt, counter, "ZOwnablePK:shield:")
 * ```
 * The commitment changes on each transfer due to the incrementing `counter`,
 * providing unlinkability across ownership changes.
 *
 * @dev Security Considerations:
 * - The `secretNonce` must be kept private. Loss of the nonce prevents the
 *   owner from proving ownership or transferring it.
 * - Ownership validation is entirely circuit-based using witness-provided values.
 * - The `_instanceSalt` is immutable and used to differentiate deployments.
 *
 * @notice Best used for single-admin contracts with privacy requirements.
 * It is not designed for multi-owner or role-based access control.
 */
module ZOwnablePK {
  import CompactStandardLibrary;
  import "../../node_modules/@openzeppelin-compact/utils/src/Initializable" prefix Initializable_;

  export ledger _ownerCommitment: Bytes<32>;
  export ledger _counter: Counter;
  export sealed ledger _instanceSalt: Bytes<32>;

  export witness secretNonce(): Bytes<32>;

  /**
   * @description Initializes the contract by setting the initial owner via `ownerId`
   * and storing the `instanceSalt` that acts as a privacy additive for preventing
   * duplicate commitments among other contracts implementing ZOwnablePK.
   *
   * @dev The `ownerId` must be calculated prior to contract deployment.
   *
   * @circuitInfo k=???, rows=???
   *
   * Requirements:
   *
   * - Contract is not initialized.
   * - `ownerId` is not all zeroes.
   *
   * @param {Bytes<32>} ownerId - The owner's unique identifier H(pk, nonce).
   * @param {Bytes<32>} instanceSalt - Contract salt to prevent duplicate commitments if
   * users reuse their PK and secretNonce witness (not recommended).
   * @returns {[]} Empty tuple.
   */
  export circuit initialize(ownerId: Bytes<32>, instanceSalt: Bytes<32>): [] {
    Initializable_initialize();

    assert(ownerId != default<Bytes<32>>, "ZOwnablePK: invalid id");
    _instanceSalt = disclose(instanceSalt);
    _transferOwnership(ownerId);
  }

  /**
   * @description Returns the current commitment representing the contract owner.
   * The full commitment is: `H(H(pk, nonce), instanceSalt, counter, domain)`.
   *
   * @circuitInfo k=???, rows=???
   *
   * Requirements:
   *
   * - Contract is initialized.
   *
   * @returns {Bytes<32>} The current owner's commitment.
   */
  export circuit owner(): Bytes<32> {
    Initializable_assertInitialized();
    return _ownerCommitment;
  }

  /**
   * @description Transfers ownership to `newOwnerId`.
   * `newOwnerId` must be precalculated and given to the current owner off chain.
   *
   * @circuitInfo k=???, rows=???
   *
   * Requirements:
   *
   * - Contract is initialized.
   * - Caller must be the current owner.
   * - `newOwnerId` must not be all zeroes.
   *
   * @param {Bytes<32>} newOwnerId - The new owner's unique identifier (`H(pk, nonce)`).
   * @returns {[]} Empty tuple.
   */
  export circuit transferOwnership(newOwnerId: Bytes<32>): [] {
    Initializable_assertInitialized();

    assertOnlyOwner();
    assert(newOwnerId != default<Bytes<32>>, "ZOwnablePK: invalid id");
    _transferOwnership(newOwnerId);
  }

  /**
   * @description Leaves the contract without an owner.
   * It will not be possible to call `assertOnlyOnwer` circuits anymore.
   * Can only be called by the current owner.
   *
   * @circuitInfo k=???, rows=???
   *
   * Requirements:
   *
   * - Contract is initialized.
   * - Caller must be the current owner.
   *
   * @returns {[]} Empty tuple.
   */
  export circuit renounceOwnership(): [] {
    Initializable_assertInitialized();

    assertOnlyOwner();
    _ownerCommitment.resetToDefault();
  }

  /**
   * @description Throws if called by any account whose id hash `H(pk, nonce)` does not match
   * the stored owner commitment.
   * Use this to restrict access of specific circuits to the owner.
   *
   * @circuitInfo k=???, rows=???
   *
   * Requirements:
   *
   * - Contract is initialized.
   * - Caller's id (`H(pk, nonce)`) when used in `_computeOwnerCommitment` must equal
   * the stored `_ownerCommitment`, thus verifying themselves as the owner.
   *
   * @returns {[]} Empty tuple.
   */
  export circuit assertOnlyOwner(): [] {
    Initializable_assertInitialized();

    const caller = ownPublicKey();
    const nonce = secretNonce();
    const id = persistentHash<Vector<2, Bytes<32>>>([caller.bytes, nonce]);
    assert(_ownerCommitment == _computeOwnerCommitment(id, _counter), "ZOwnablePK: caller is not the owner");
  }

  /**
   * @description Computes the owner commitment from the given `id` and `counter`.
   *
   * ## Owner ID (`id`)
   * The `id` is expected to be computed off-chain as:
   * `id = H(pk, nonce)`
   *
   * - `pk`: The owner's public key.
   * - `nonce`: A secret nonce scoped to the instance, ideally rotated with each transfer.
   *
   * ## Commitment Derivation
   * `commitment = H(id, instanceSalt, counter, domain)`
   *
   * - `id`: See above.
   * - `instanceSalt`: A unique per-deployment salt, stored during initialization.
   *   This prevents commitment collisions across deployments.
   * - `counter`: Incremented with each ownership transfer, ensuring uniqueness
   *   even with repeated `id` values.
   * - `domain`: A domain separator to prevent hash collisions when extending the module.
   *
   * Requirements:
   *
   * - Contract is initialized.
   *
   * @param {Bytes<32>} id - The unique identifier of the owner calculated by `H(pk, nonce)`.
   * @param {Uint<64>} counter - The current counter or round. This increments by `1`
   * after every transfer to prevent duplicate commitments given the same `id`.
   * @returns {Bytes<32>} The commitment derived from `id` and `counter`.
   */
  export circuit _computeOwnerCommitment(
    id: Bytes<32>,
    counter: Uint<64>,
  ): Bytes<32> {
    Initializable_assertInitialized();
    return persistentHash<Vector<4, Bytes<32>>>(
      [
        id,
        _instanceSalt,
        counter as Field as Bytes<32>,
        pad(32, "ZOwnablePK:shield:")
      ]
    );
  }

  /**
   * @description Computes the unique identifier (`id`) of the owner from their
   * public key and a secret nonce.
   *
   * ## ID Derivation
   * `id = H(pk, nonce)`
   *
   * - `pk`: The public key of the caller. This is passed explicitly to allow
   *   for off-chain derivation, testing, or scenarios where the caller is
   *   different from the subject of the computation.
   * - `nonce`: A secret nonce tied to the identity. This value should be
   *   randomly generated and kept private. It may be rotated periodically
   *   for enhanced unlinkability.
   *
   * The result is a 32-byte commitment that uniquely identifies the owner.
   * This value is later used in owner commitment hashing, and acts as a privacy-preserving
   * alternative to a raw public key.
   *
   * @notice This module allows ownership to be tied to an identity commitment derived
   * from a public key and secret nonce.
   * While typically used with user public keys, this mechanism may also
   * support contract addresses as identifiers in future contract-to-contract
   * interactions. Both are treated as 32-byte values (`Bytes<32>`).
   *
   * @circuitInfo k=???, rows=???
   *
   * Requirements:
   *
   * - `pk` is not a ContractAddress.
   *
   * @param {Bytes<32>} pk - The public key of the identity being committed.
   * @param {Bytes<32>} nonce - A private nonce to scope the commitment.
   * @returns {Bytes<32>} The computed owner ID.
   */
  export pure circuit _computeOwnerId(pk: Either<ZswapCoinPublicKey, ContractAddress>, nonce: Bytes<32>): Bytes<32> {
    if (!pk.is_left) {
      assert(false, "ZOwnablePK: contract address owners are not yet supported");
    }

    return persistentHash<Vector<2, Bytes<32>>>([pk.left.bytes, nonce]);
  }

  /**
   * @description Transfers ownership to owner id `newOwnerId` without
   * enforcing permission checks on the caller.
   *
   * @circuitInfo k=???, rows=???
   *
   * Requirements:
   *
   * - Contract is initialized.
   *
   * @param {Bytes<32>} newOwnerId - The unique identifier of the new owner
   * calculated by `H(pk, nonce)`.
   * @returns {[]} Empty tuple.
   */
  export circuit _transferOwnership(newOwnerId: Bytes<32>): [] {
    Initializable_assertInitialized();

    _counter.increment(1);
    _ownerCommitment = _computeOwnerCommitment(disclose(newOwnerId), _counter);
  }
}
