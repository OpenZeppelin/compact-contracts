// SPDX-License-Identifier: MIT

pragma language_version >= 0.16.0;

/**
 * @module ZOwnablePK
 * @description A shielded Ownable library.
 */
module ZOwnablePK {
  import CompactStandardLibrary;

  export ledger _ownerCommitment: Bytes<32>;
  export ledger _counter: Counter;
  export sealed ledger _instanceSalt: Bytes<32>;

  export witness offchainNonce(): Bytes<32>;

  /**
   * @description Add me!!!
   */
  export circuit initialize(ownerId: Bytes<32>, instanceSalt: Bytes<32>): [] {
    assert(ownerId != default<Bytes<32>>, "Invalid parameters");
    _instanceSalt = disclose(instanceSalt);
    _transferOwnership(ownerId);
  }

  /**
   * @description Add me!!!
   */
  export circuit owner(): Bytes<32> {
    return _ownerCommitment;
  }

  /**
   * @description Add me!!!
   */
  export circuit transferOwnership(newOwnerId: Bytes<32>): [] {
    assertOnlyOwner();
    assert(newOwnerId != default<Bytes<32>>, "Invalid parameters");
    _transferOwnership(newOwnerId);
  }

  /**
   * @description Add me!!!
   */
  export circuit renounceOwnership(): [] {
    assertOnlyOwner();
    _ownerCommitment.resetToDefault();
  }

  /**
   * @description Add me!!!
   */
  export circuit assertOnlyOwner(): [] {
    const caller = ownPublicKey();
    const nonce = offchainNonce();
    const id = persistentHash<Vector<2, Bytes<32>>>([caller.bytes, nonce]);
    assert(_ownerCommitment == computeOwnerCommitment(id, _counter), "Forbidden");
  }

  // computePKCommitment || generateCommitment
  /**
   * @description Add me!!!
   */
  export circuit computeOwnerCommitment(
    id: Bytes<32>,
    counter: Uint<64>,
  ): Bytes<32> {
    return persistentHash<Vector<4, Bytes<32>>>(
      [
        id,
        _instanceSalt,
        counter as Field as Bytes<32>,
        pad(32, "ZOwnablePK:shield:")
      ]
    );
  }

  /**
   * @description Add me!!!
   */
  export circuit _transferOwnership(newOwnerId: Bytes<32>): [] {
    _counter.increment(1);
    _ownerCommitment = computeOwnerCommitment(disclose(newOwnerId), _counter);
  }
}
