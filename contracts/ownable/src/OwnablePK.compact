// SPDX-License-Identifier: MIT

pragma language_version >= 0.15.0;

/**
 * @module Shielded Ownable Public Key module
 * @description The OwnablePK module provides a basic access control mechanism,
 * where there is an account (an owner) that can be granted exclusive access
 * to specific circuits.
 *
 * The initial owner can be set by using the `initializer` circuit during
 * construction. The owner's public key will be obfuscated in the ledger
 * (thus shielded) by the `shieldOwner` circuit.
 *
 * This module enforces a two-step ownership transfer mechanism. The mechanism
 * flow starts with the current owner calling `transferOwnership` and passing
 * the new owner's ZswapCoinPublicKey. The proposed owner's key is obfuscated
 * similarly via the `shieldOwner` circuit. After the owner proposes the new
 * owner, the new owner must accept ownership by calling `acceptOwnership`.
 * This circuit validates that the caller is the proposed owner. Thereafter,
 * the new owner may call `assertOnlyOwner` circuits.
 *
 * The reason this module enforces the two-step mechanism is for safety.
 * If the owner transferred ownership to the wrong pubkey without the mechanism,
 * it's likely that the ownership privileges will be lost for the contract forever.
 * With the two-step mechanism, the current owner can overwrite the pending
 * owner by calling `transferOwnership` with a different pubkey or passing
 * zero to cancel the transfer.
 */
module OwnablePK {
  import CompactStandardLibrary;

  /** Public state */
  export ledger _owner: Bytes<32>;
  export ledger _pendingOwner: Bytes<32>;
  export ledger _instance: Counter;

  /**
   * @description Initializes the contract by setting `initOwner` as the
   * (shielded) contract owner.
   *
   * @returns {[]} - None.
   */
  export circuit initializer(initOwner: ZswapCoinPublicKey): [] {
    assert initOwner != burn_address().left "OwnablePK: new owner cannot be zero";
    const nextInstance = _instance + 1 as Field as Bytes<32>;
    const shieldedOwner = shieldOwner(initOwner, nextInstance);
    _transferOwnership(shieldedOwner);
  }

  /**
   * @description Returns the shielded owner.
   *
   * @returns {Bytes<32>} - The shielded owner.
   */
  export circuit owner(): Bytes<32> {
    return _owner;
  }

  /**
   * @description Returns the shielded pending owner.
   *
   * @returns {Bytes<32>} - The shielded proposed owner.
   */
  export circuit pendingOwner(): Bytes<32> {
    return _pendingOwner;
  }

  /**
   * @description Initiates the two-step ownership transfer to `newOwner`.
   * To cancel an ownership transfer, the current owner can call this circuit
   * and pass zero as `newOwner`.
   *
   * Requirements:
   *
   * - The caller must be the current contract owner.
   *
   * @returns {[]} - None.
   */
  export circuit transferOwnership(newOwner: ZswapCoinPublicKey): [] {
    assertOnlyOwner();
    _proposeOwner(newOwner);
  }

  /**
   * @description Finishes the two-step ownership transfer process by accepting
   * the ownership. Can only be called by the pending owner.
   *
   * Requirements:
   *
   * - The caller is the pending owner.
   *
   * @returns {[]} - None.
   */
  export circuit acceptOwnership(): [] {
    const caller = own_public_key();
    const nextInstance = _instance + 1 as Field as Bytes<32>;
    const shieldedOwner = shieldOwner(caller, nextInstance);
    assert shieldedOwner == _pendingOwner "OwnablePK: caller is not pending owner";

    // Reset pending owner and assign new owner
    _transferOwnership(shieldedOwner);
  }

  /**
   * @description Leaves the contract without an owner. It will not be
   * possible to call `assertOnlyOnwer` circuits anymore. Can only be
   * called by the current owner.
   *
   * Requirements:
   *
   * - The caller is the contract owner.
   *
   * @returns {[]} - None.
   */
  export circuit renounceOwnership(): [] {
    assertOnlyOwner();
    _transferOwnership(default<Bytes<32>>);
  }

  /**
   * @description Throws if called by any account other than the owner.
   * Use this to restrict access to sensitive circuits.
   *
   * @returns {[]} - None.
   */
  export circuit assertOnlyOwner(): [] {
    const caller = own_public_key();
    assert _owner == shieldOwner(caller, _instance as Field as Bytes<32>) "OwnablePK: not owner";
  }

  /**
   * @description Obfuscates the `ownerPK` be hashing it with a domain separator and
   * the passed `instance`.
   *
   * @returns {Bytes<32>} - The shielded hash of the owner and instance.
   */
  export circuit shieldOwner(ownerPK: ZswapCoinPublicKey, instance: Bytes<32>): Bytes<32> {
    return persistent_hash<Vector<3, Bytes<32>>>([pad(32, "OwnablePK:shield:"), instance, ownerPK.bytes]);
  }

  /**
   * @description Internal circuit that transfers ownership of the contract to `newOwner`.
   * This circuit does not have access control and thus should not be exposed.
   *
   * Be careful with this circuit. `newOwner` will be stored in the ledger as it's
   * passed meaning that `newOwner` must be shielded via `shieldOwner` beforehand.
   * Maybe include `shieldOwner()` in logic so it's difficult to misuse?
   */
  export circuit _transferOwnership(newOwner: Bytes<32>): [] {
    _pendingOwner = default<Bytes<32>>;
    _instance.increment(1);
    _owner = newOwner;
  }

  /**
   * @description Internal circuit that sets the pending owner.
   * Passing `newOwner` as zero cancels the two-step ownership
   * transfer. Otherwise, this circuit shields `newOwner` and
   * sets it in the ledger.
   *
   * @returns {[]} - None.
   */
  export circuit _proposeOwner(newOwner: ZswapCoinPublicKey): [] {
    if (newOwner == burn_address().left) {
      _pendingOwner = pad(32, "");
    } else {
      const nextInstance = _instance + 1 as Field as Bytes<32>;
      _pendingOwner = shieldOwner(newOwner, nextInstance);
    }
  }
}
