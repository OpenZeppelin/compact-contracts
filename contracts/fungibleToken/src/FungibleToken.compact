// SPDX-License-Identifier: MIT

pragma language_version >= 0.15.0;

/**
 * @module FungibleToken
 * @description An unshielded FungibleToken library.
 *
 * @notice One notable difference regarding this implementation and the EIP20 spec
 * consists of the token size. Uint<128> is used as the token size because Uint<256>
 * cannot be supported.
 * This is due to encoding limits on the midnight circuit backend:
 * https://github.com/midnightntwrk/compactc/issues/929
 *
 * @notice Further discussion and consideration required:
 *
 * - Consider changing the underscore in the internal methods to `unsafe` or
 * adopting dot notation for prefixing imports.
 * - Revise logic once contract-to-contract interactions are available on midnight.
 * - Consider implementing an introspection mechanism for transfers to contracts.
 * - Standardize which zero address to use (`ZswapCoinPublicKey` or `ContractAddress`).
 */
module FungibleToken {
  import CompactStandardLibrary;
  import "../../node_modules/@openzeppelin-midnight/utils/src/Initializable" prefix Initializable_;
  import "../../node_modules/@openzeppelin-midnight/utils/src/Utils" prefix Utils_;

  /// Public state
  export sealed ledger _name: Opaque<"string">;
  export sealed ledger _symbol: Opaque<"string">;
  export sealed ledger _decimals: Uint<8>;
  export ledger _totalSupply: Uint<128>;
  export ledger _balances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>;
  export ledger _allowances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>>;

  /**
   * @description Initializes the contract by setting the name, symbol, and decimals.
   * @dev This MUST be called in the implementing contract's constructor. Failure to do so
   * can lead to an irreparable contract.
   *
   * @param name_ - The name of the token.
   * @param symbol_ - The symbol of the token.
   * @param decimals_ - The number of decimals used to get the user representation.
   * @return {[]} - None.
   */
  export circuit initializer(
    name_: Opaque<"string">,
    symbol_: Opaque<"string">,
    decimals_:Uint<8>
  ): [] {
    Initializable_initialize();
    _name = name_;
    _symbol = symbol_;
    _decimals = decimals_;
  }

  /**
   * @description Returns the token name.
   *
   * @return {Opaque<"string">} - The token name.
   */
  export circuit name(): Opaque<"string"> {
    Initializable_assertInitialized();
    return _name;
  }

  /**
   * @description Returns the symbol of the token.
   *
   * @return {Opaque<"string">} - The token name.
   */
  export circuit symbol(): Opaque<"string"> {
    Initializable_assertInitialized();
    return _symbol;
  }

  /**
   * @description Returns the number of decimals used to get its user representation.
   *
   * @return {Uint<8>} - The account's token balance.
   */
  export circuit decimals(): Uint<8> {
    Initializable_assertInitialized();
    return _decimals;
  }

  /**
   * @description Returns the value of tokens in existence.
   *
   * @return {Uint<128>} - The total supply of tokens.
   */
  export circuit totalSupply(): Uint<128> {
    Initializable_assertInitialized();
    return _totalSupply;
  }

  /**
   * @description Returns the value of tokens owned by `account`.
   *
   * @dev Manually checks if `account` is a key in the map and returns 0 if it is not.
   *
   * @param {account} - The public key or contract address to query.
   * @return {Uint<128>} - The account's token balance.
   */
  export circuit balanceOf(account: Either<ZswapCoinPublicKey, ContractAddress>): Uint<128> {
    Initializable_assertInitialized();
    if (!_balances.member(account)) {
      return 0;
    }

    return _balances.lookup(account);
  }

  /**
   * @description Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner`
   *              through `transferFrom`. This value changes when `approve` or `transferFrom` are called.
   *
   * @dev Manually checks if `owner` and `spender` are keys in the map and returns 0 if they are not.
   *
   * @param {owner} - The public key or contract address of approver.
   * @param {spender} - The public key or contract address of spender.
   * @return {Uint<128>} - The `spender`'s allowance over `owner`'s tokens.
   */
  export circuit allowance(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    spender: Either<ZswapCoinPublicKey, ContractAddress>
  ): Uint<128> {
    Initializable_assertInitialized();
    if (!_allowances.member(owner) || !_allowances.lookup(owner).member(spender)) {
      return 0;
    }

    return _allowances.lookup(owner).lookup(spender);
  }

  /**
   * @description Moves a `value` amount of tokens from the caller's account to `to`.
   *
   * @dev We need to get the caller address from contracts and handle the transfer appropriately.
   *      This should include a callback to ensure the contract can safely receive tokens.
   *
   * @param {to} - The recipient of the transfer, either a user or a contract.
   * @param {value} - The amount to transfer.
   * @return {Boolean} - As per the IERC20 spec, this MUST return true.
   */
  export circuit transfer(to: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>): Boolean {
    Initializable_assertInitialized();
    assert !Utils_isContractAddress(to) "FungibleToken: unsafe transfer";
    return _unsafeTransfer(to, value);
  }

  /**
   * @description Unsafe variant of `transfer` which allows transfers to contract addresses.
   *
   * @warning Transfers to contract addresses are considered unsafe because contract-to-contract
   * calls are not currently supported. Tokens sent to a contract address may become irretrievable.
   * Once contract-to-contract calls are supported, this circuit may be deprecated.
   *
   * @param {to} - The recipient of the transfer, either a user or a contract.
   * @param {value} - The amount to transfer.
   * @return {Boolean} - As per the IERC20 spec, this MUST return true.
   */
  export circuit _unsafeTransfer(to: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>): Boolean {
    Initializable_assertInitialized();
    // TMP - Waiting for contract-to-contract calls to handle `right` with contract address
    const owner = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
    _transfer(owner, to, value);
    return true;
  }

  /**
   * @description Moves `value` tokens from `from` to `to` using the allowance mechanism.
   * `value` is the deducted from the caller's allowance.
   *
   * @dev We need to get the caller address from contracts and handle the transfer appropriately.
   *      This should include a callback to ensure the contract can safely receive tokens.
   *
   * @param {from} - The current owner of the tokens for the transfer, either a user or a contract.
   * @param {to} - The recipient of the transfer, either a user or a contract.
   * @param {value} - The amount to transfer.
   * @return {Boolean} - As per the IERC20 spec, this MUST return true.
   */
  export circuit transferFrom(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): Boolean {
    Initializable_assertInitialized();
    assert !Utils_isContractAddress(to) "FungibleToken: unsafe transfer";
    return _unsafeTransferFrom(from, to, value);
  }

  /**
   * @description Unsafe variant of `transferFrom` which allows transfers to contract addresses.
   *
   * @warning Transfers to contract addresses are considered unsafe because contract-to-contract
   * calls are not currently supported. Tokens sent to a contract address may become irretrievable.
   * Once contract-to-contract calls are supported, this circuit may be deprecated.
   *
   * @param {from} - The current owner of the tokens for the transfer, either a user or a contract.
   * @param {to} - The recipient of the transfer, either a user or a contract.
   * @param {value} - The amount to transfer.
   * @return {Boolean} - As per the IERC20 spec, this MUST return true.
   */
  export circuit _unsafeTransferFrom(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): Boolean {
    Initializable_assertInitialized();
    // TMP - Waiting for contract-to-contract calls to handle `right` with contract address
    const spender = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
    _spendAllowance(from, spender, value);
    _transfer(from, to, value);
    return true;
  }

  /**
   * @description Sets a `value` amount of tokens as allowance of `spender` over the caller's tokens.
   *
   * @param {spender} - The Zswap key or ContractAddress that may spend on behalf of the caller.
   * @param {value} - The amount of tokens the `spender` may spend.
   * @return {Boolean} - Returns a boolean value indicating whether the operation succeeded.
   */
  export circuit approve(spender: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>): Boolean {
    Initializable_assertInitialized();
    // TMP - Waiting for contract-to-contract calls to handle `right` with contract address
    const owner = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
    _approve(owner, spender, value);
    return true;
  }

  /**
   * @description Sets `value` as the allowance of `spender` over the `owner`'s tokens.
   * This circuit is equivalent to `approve`, and can be used to
   * e.g. set automatic allowances for certain subsystems, etc.
   *
   * @param {owner} - The owner of the tokens.
   * @param {spender} - The spender of the tokens.
   * @param {value} - The amount of tokens `spender` may spend on behalf of `owner`.
   * @return {[]} - None.
   */
  export circuit _approve(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    spender: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): [] {
    Initializable_assertInitialized();
    assert !Utils_isKeyOrAddressZero(owner) "FungibleToken: invalid owner";
    assert !Utils_isKeyOrAddressZero(spender) "FungibleToken: invalid spender";
    if (!_allowances.member(owner)) {
      // If owner doesn't exist, create and insert a new sub-map directly
      _allowances.insert(owner, default<Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>>);
    }
    _allowances.lookup(owner).insert(spender, value);
  }

  /**
   * @description Moves a `value` amount of tokens from `from` to `to`.
   * This circuit is equivalent to {transfer}, and can be used to
   * e.g. implement automatic token fees, slashing mechanisms, etc.
   *
   * @param {from} - The owner of the tokens to transfer.
   * @param {to} - The receipient of the transferred tokens.
   * @param {value} - The amount of tokens to transfer.
   * @return {[]} - None.
   */
  export circuit _transfer(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): [] {
    Initializable_assertInitialized();
    assert !Utils_isKeyOrAddressZero(from) "FungibleToken: invalid sender";
    assert !Utils_isKeyOrAddressZero(to) "FungibleToken: invalid receiver";

    _update(from, to, value);
  }

  /**
   * @description Creates a `value` amount of tokens and assigns them to `account`,
   * by transferring it from the zero address. Relies on the `update` mechanism.
   *
   * @param {account} - The recipient of tokens minted.
   * @param {value} - The amount of tokens minted.
   * @return {[]} - None.
   */
  export circuit _mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): [] {
    Initializable_assertInitialized();
    assert !Utils_isKeyOrAddressZero(account) "FungibleToken: invalid receiver";
    _update(burn_address(), account, value);
  }

  /**
   * @description Destroys a `value` amount of tokens from `account`, lowering the total supply.
   * Relies on the `_update` mechanism.
   *
   * @param {account} - The target owner of tokens to burn.
   * @param {value} - The amount of tokens to burn.
   * @return {[]} - None.
   */
  export circuit _burn(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): [] {
    Initializable_assertInitialized();
    assert !Utils_isKeyOrAddressZero(account) "FungibleToken: invalid sender";
    _update(account, burn_address(), value);
  }

  /**
   * @description Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`
   * (or `to`) is the zero address.
   * @dev Checks for a mint overflow in order to output a more readable error message.
   *
   * @param {from} - The original owner of the tokens moved (which is 0 if tokens are minted).
   * @param {to} - The recipient of the tokens moved (which is 0 if tokens are burned).
   * @param {value} - The amount of tokens moved from `from` to `to`.
   * @return {[]} - None.
   */
  export circuit _update(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): [] {
    Initializable_assertInitialized();
    if (Utils_isKeyOrAddressZero(from)) {
      // Mint
      const MAX_UINT128 = 340282366920938463463374607431768211455;
      assert MAX_UINT128 - _totalSupply >= value "FungibleToken: arithmetic overflow";

      _totalSupply = _totalSupply + value as Uint<128>;
    } else {
      const fromBal = balanceOf(from);
      assert fromBal >= value "FungibleToken: insufficient balance";
      _balances.insert(from, fromBal - value as Uint<128>);
    }

    if (Utils_isKeyOrAddressZero(to)) {
      // Burn
      _totalSupply = _totalSupply - value as Uint<128>;
    } else {
      const toBal = balanceOf(to);
      _balances.insert(to, toBal + value as Uint<128>);
    }
  }

  /**
   * @description Updates `owner`'s allowance for `spender` based on spent `value`.
   * Does not update the allowance value in case of infinite allowance.
   *
   * @param {owner} - The owner of the tokens.
   * @param {spender} - The spender of the tokens.
   * @param {value} - The amount of token allowance to spend.
   * @return {[]} - None.
   */
  export circuit _spendAllowance(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    spender: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
  ): [] {
    Initializable_assertInitialized();
    // TODO: Look into improving design so we're not checking allowance member twice (here and in `_approve`)
    assert (_allowances.member(owner) && _allowances.lookup(owner).member(spender)) "FungibleToken: insufficient allowance";

    const currentAllowance = _allowances.lookup(owner).lookup(spender);
    // TODO: improve readability of max_u128
    const MAX_UINT128 = 340282366920938463463374607431768211455;
    if (currentAllowance < MAX_UINT128) {
      assert currentAllowance >= value "FungibleToken: insufficient allowance";
      _approve(owner, spender, currentAllowance - value as Uint<128>);
    }
  }
}
