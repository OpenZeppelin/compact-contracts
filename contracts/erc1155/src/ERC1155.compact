// SPDX-License-Identifier: MIT
pragma language_version >= 0.14.0;

/**
 * @module ERC1155
 * @description An unshielded ERC1155 library.
 *
 * @notice One notable difference regarding this implementation and the EIP1155 spec
 * consists of the token size. Uint<128> is used as the token size because Uint<256>
 * cannot be supported. This is true for both token IDs and for amounts.
 * This is due to encoding limits on the midnight circuit backend:
 * https://github.com/midnightntwrk/compactc/issues/929
 *
 * @notice Querying balanceOfBatch is currently supported; however,
 * the number of balances to query is set as a generic `n` number.
 * The implementing contract must define the size(s) that the contract
 * is going to expose and queries must then be padded if queries < `n`.
 *
 * @notice Some features defined in th EIP1155 spec are NOT included.
 * Such features include:
 *
 * 1. Batch mint, burn, transfer - Without support for dynamic arrays,
 * batching transfers is difficult to do without a hacky solution.
 * For instance, we could change the `to` and `from` parameters to be
 * vectors. This would change the signature and would be both difficult
 * to use and easy to misuse.
 *
 * 2. Introspection - Compact currently cannot support contract-to-contract
 * queries for introspection. ERC165 (or an equivalent thereof) is NOT
 * included in the contract.
 *
 * 3. Safe transfers - The lack of an introspection mechanism means
 * safe transfers of any kind can not be supported.
 * BE AWARE: Tokens sent to a contract address MAY be lost forever.
 *
 * @notice Further discussion and consideration required:
 *
 * - Consider changing the underscore in the internal methods to `unsafe` or
 * adopting dot notation for prefixing imports.
 * - Revise logic once contract-to-contract interactions are available on midnight.
 * - Standardize which zero address to use (`ZswapCoinPublicKey` or `ContractAddress`).
 */
module ERC1155 {
  import CompactStandardLibrary;
  import "../../node_modules/@openzeppelin-midnight-contracts/utils-contract/src/Utils" prefix Utils_;

  /// Public state
  export ledger _balances: Map<Field, Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>>;
  export ledger _operatorApprovals: Map<Either<ZswapCoinPublicKey, ContractAddress>, Map<Either<ZswapCoinPublicKey, ContractAddress>, Boolean>>;
  // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json
  export ledger _uri: Maybe<Opaque<"string">>;

  /**
   * @description Initializes the contract by setting the base URI for all tokens.
   *
   * @param {uri_} - The base URI for all token URIs.
   * @return {[]} None.
   */
  export circuit initializer(
    uri_: Maybe<Opaque<"string">>
  ): [] {
    _uri = uri_;
  }

  /**
   * @description This implementation returns the same URI for *all* token types. It relies
   * on the token type ID substitution mechanism defined in the EIP:
   * https://eips.ethereum.org/EIPS/eip-1155#metadata.
   * Clients calling this function must replace the `\{id\}` substring with the
   * actual token type ID.
   *
   * @param {id} - The token identifier to query.
   * return {Maybe<Opaque<"string">>} - The base URI for all tokens.
   */
  export circuit uri(id: Field): Maybe<Opaque<"string">> {
    return _uri;
  }

  /**
   * @description Returns the amount of `id` tokens owned by `account`.
   *
   * @param {account} - The account balance to query.
   * @param {id} - The token identifier to query.
   * return {Uint<128>} - The quantity of `id` tokens that `account` owns.
   */
  export circuit balanceOf(account: Either<ZswapCoinPublicKey, ContractAddress>, id: Field): Uint<128> {
    if (!_balances.member(id) || !_balances.lookup(id).member(account)) {
      return 0;
    }
    return _balances.lookup(id).lookup(account);
  }

  /**
   * @description Get the balance of multiple account/token pairs.
   * @dev Compact does not support dynamic arrays; therefore, the implementing contract
   * must explicitly declare the quantity of pairs to check. Some ideas:
   * - Define one `balanceOfBatch` with a max value for n that must not be exceeded. Any
   * unused pair elements in the vector can be padded.
   * - Define multiple `balanceOfBatch` with differing n values. The contract can
   * have 10, 100, 1000, etc. values for n and can pad any remaining pairs.
   *
   * @param {accounts} - The ZswapCoinPublicKey or ContractAddress whose approval is set for the
   * caller's assets.
   * @param {ids} - The boolean value determining if the operator may or may not handle the
   * caller's assets.
   * @return {Vector<n, Uint<128>>} Returns n balances of account/token id pairs.
   */
  export circuit balanceOfBatch<#n>(
    accounts: Vector<n, Either<ZswapCoinPublicKey, ContractAddress>>,
    ids: Vector<n, Uint<128>>
  ): Vector<n, Uint<128>> {
    return map(balanceOf, accounts, ids);
  }

  /**
   * @description Enables or disables approval for `operator` to manage all of the caller's assets.
   *
   * @param {operator} - The ZswapCoinPublicKey or ContractAddress whose approval is set for the
   * caller's assets.
   * @param {approved} - The boolean value determining if the operator may or may not handle the
   * caller's assets.
   * @return {[]} None.
   */
  export circuit setApprovalForAll(operator: Either<ZswapCoinPublicKey, ContractAddress>, approved: Boolean): [] {
    // TMP - Waiting for contract-to-contract calls to handle `right` with contract address
    const caller = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
    _setApprovalForAll(caller, operator, approved);
  }

  /**
   * @description Queries if `operator` is an authorized operator for `owner`.
   *
   * @param {account} - The queried possessor of assets.
   * @param {operator} - The queried handler of `account`'s assets.
   * @return {Boolean} - Whether or not `operator` has permission to handle `account`'s assets.
   */
  export circuit isApprovedForAll(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    operator: Either<ZswapCoinPublicKey, ContractAddress>
  ): Boolean {
    if (!_operatorApprovals.member(account) || !_operatorApprovals.lookup(account).member(operator)) {
      return false;
    }

    return _operatorApprovals.lookup(account).lookup(operator);
  }

  /**
   * @description Transfers ownership of `value` amount of `token_id` from `from` to `to`.
   * @notice This circuit checks that the caller is either `from` or is approved
   * to transfer on behalf of `from`.
   *
   * @param {from} - The owner from which the transfer originates.
   * @param {to} - The recipient of the transferred assets.
   * @param {id} - The unique identifier of the asset type.
   * @param {value} - The quantity of `id` tokens to transfer.
   * @return {[]} None.
   */
  export circuit transferFrom(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    id: Field,
    value: Uint<128>
  ): [] {
    // TMP - Waiting for contract-to-contract calls to handle `right` with contract address
    const caller = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
    if (from != caller) {
      assert isApprovedForAll(from, caller) "ERC1155: unauthorized operator";
    }

    _transferFrom(from, to, id, value);
  }

  /**
   * @description Internal circuit that transfers ownership of `value` amount of `token_id` from `from` to `to`.
   * @notice This internal circuit does not check for access permissions but can be useful as a building block
   * for more complex contract logic.
   *
   * @param {from} - The owner from which the transfer originates.
   * @param {to} - The recipient of the transferred assets.
   * @param {id} - The unique identifier of the asset type.
   * @param {value} - The quantity of `id` tokens to transfer.
   * @return {[]} None.
   */
  export circuit _transferFrom(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    id: Field,
    value: Uint<128>
  ): [] {
    assert !Utils_isKeyOrAddressZero(from) "ERC1155: invalid sender";
    assert !Utils_isKeyOrAddressZero(to) "ERC1155: invalid receiver";
    _update(from, to, id, value);
  }

  /**
   * @description Transfers a value amount of tokens of type id from from to to.
   * This circuit will mint (or burn) if `from` (or `to`) is the zero address.
   *
   * @param {from} - The origin of the transfer.
   * @param {to} - The destination of the transfer.
   * @param {id} - The unique identifier of the asset type.
   * @param {value} - The quantity of `id` tokens to transfer.
   * @return {[]} None.
   */
  export circuit _update(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    id: Field,
    value: Uint<128>
  ): [] {
    if (!Utils_isKeyOrAddressZero(from)) {
      const fromBalance = balanceOf(from, id);
      assert fromBalance >= value "ERC1155: insufficient balance";
      // overflow not possible
      const newBalance = fromBalance - value;
      _balances.lookup(id).insert(from, newBalance);
    }

    if (!Utils_isKeyOrAddressZero(to)) {
      // id not initialized
      if (!_balances.member(id)) {
        _balances.insert(id, default<Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>>);
        _balances.lookup(id).insert(to, value as Uint<128>);
      } else {
        const toBalance = balanceOf(to, id);
        const MAX_UINT128 = 340282366920938463463374607431768211455;
        assert MAX_UINT128 - toBalance >= value "ERC1155: arithmetic overflow";
        _balances.lookup(id).insert(to, toBalance + value as Uint<128>);
      }
    }
  }

  /**
   * @description Sets a new URI for all token types, by relying on the token type ID
   * substitution mechanism defined in the ERC1155 standard.
   * See https://eips.ethereum.org/EIPS/eip-1155#metadata.
   *
   * @notice By this mechanism, any occurrence of the `\{id\}` substring in either the
   * URI or any of the values in the JSON file at said URI will be replaced by
   * clients with the token type ID.
   *
   * For example, the `https://token-cdn-domain/\{id\}.json` URI would be
   * interpreted by clients as
   * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`
   * for token type ID 0x4cce0.
   *
   * @param {newURI} - The new base URI for all tokens.
   * @return {[]} - None.
   */
  export circuit _setURI(newURI: Maybe<Opaque<"string">>): [] {
    _uri = newURI;
  }

  /**
   * @description Creates a `value` amount of tokens of type `token_id`, and assigns them to `to`.
   *
   * @param {to} - The recipient of the minted tokens.
   * @param {id} - The unique identifier for the token type.
   * @param {value} - The quantity of `id` tokens that are minted to `to`.
   * @return {[]} - None.
   */
  export circuit _mint(to: Either<ZswapCoinPublicKey, ContractAddress>, id: Field, value: Uint<128>): [] {
    assert !Utils_isKeyOrAddressZero(to) "ERC1155: invalid receiver";
    _update(burn_address(), to, id, value);
  }

  /**
   * @description Destroys a `value` amount of tokens of type `token_id` from `from`.
   *
   * @param {from} - The owner whose tokens will be destroyed.
   * @param {id} - The unique identifier of the token type.
   * @param {value} - The quantity of `id` tokens that will be destroyed from `from`.
   * @return {[]} - None.
   */
  export circuit _burn(from: Either<ZswapCoinPublicKey, ContractAddress>, id: Field, value: Uint<128>): [] {
    assert !Utils_isKeyOrAddressZero(from) "ERC1155: invalid sender";
    _update(from, burn_address(), id, value);
  }

  /**
   * @description Enables or disables approval for `operator` to manage all of the caller's assets.
   * @notice This internal circuit does not check for access permissions but can be useful as a building block
   * for more complex contract logic.
   *
   * @param {owner} - The ZswapCoinPublicKey or ContractAddress of the target owner.
   * @param {operator} - The ZswapCoinPublicKey or ContractAddress whose approval is set for the
   * `owner`'s assets.
   * @param {approved} - The boolean value determining if the operator may or may not handle the
   * `owner`'s assets.
   * @return {[]} None.
   */
  export circuit _setApprovalForAll(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    operator: Either<ZswapCoinPublicKey, ContractAddress>,
    approved: Boolean
  ): [] {
    assert !Utils_isKeyOrAddressZero(operator) "ERC1155: invalid operator";
    if (!_operatorApprovals.member(owner)) {
      _operatorApprovals.insert(owner, default<Map<Either<ZswapCoinPublicKey, ContractAddress>, Boolean>>);
    }

    _operatorApprovals.lookup(owner).insert(operator, approved);
  }
}
