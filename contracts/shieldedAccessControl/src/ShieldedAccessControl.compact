// SPDX-License-Identifier: MIT

pragma language_version >= 0.16.0;

/**
 * @module Shielded AccessControl
 * @description A Shielded AccessControl library.
 * This module provides a role-based access control mechanism, where roles can be used to
 * represent a set of permissions. Roles are stored as MerkleTree commitments to avoid
 * disclosing information regarding the roles an account may have. Commitments are created
 * with SHA256(PublicKey | roleIdentifier | nonce).
 *
 * @notice Using the SHA256 hashing function comes at a significant performace cost. In the future, we
 * plan on migrating to a ZK-friendly hashing function like Poseidon when an implementation is available.
 *
 * Roles are referred to by their `Bytes<32>` identifier. These should be exposed
 * in the top-level contract and be unique. One way to achieve this is by
 * using `export sealed ledger` hash digests that are initialized in the top-level contract:
 *
 * ```typescript
 * import CompactStandardLibrary;
 * import "./node_modules/@openzeppelin-compact/accessControl/src/ShieldedAccessControl" prefix ShieldedAccessControl_;
 *
 * export sealed ledger MY_ROLE: Bytes<32>;
 *
 * constructor() {
 *  MY_ROLE = persistentHash<Bytes<32>>(pad(32, "MY_ROLE"));
 * }
 * ```
 *
 * To restrict access to a circuit, use {assertOnlyRole}:
 *
 * ```typescript
 * circuit foo(): [] {
 *  assertOnlyRole(MY_ROLE);
 *  ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} circuits. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}. To set a custom `DEFAULT_ADMIN_ROLE`, implement the `Initializable`
 * module and set `DEFAULT_ADMIN_ROLE` in the `initialize()` circuit.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 *
 * @notice Roles can only be granted to ZswapCoinPublicKeys
 * through the main role approval circuits (`grantRole` and `_grantRole`).
 * In other words, role approvals to contract addresses are disallowed through these
 * circuits.
 * This is because Compact currently does not support contract-to-contract calls which means
 * if a contract is granted a role, the contract cannot directly call the protected
 * circuit.
 *
 * @notice This module does offer an experimental circuit that allows roles to be granted
 * to contract addresses (`_unsafeGrantRole`).
 * Note that the circuit name is very explicit ("unsafe") with this experimental circuit.
 * Until contract-to-contract calls are supported,
 * there is no direct way for a contract to call protected circuits.
 *
 * @notice The unsafe circuits are planned to become deprecated once contract-to-contract calls
 * are supported.
 *
 * @notice Missing Features and Improvements:
 *
 * - Role events
 * - An ERC165-like interface
 */
module ShieldedAccessControl {
  import CompactStandardLibrary;
  import "../../node_modules/@openzeppelin-compact/utils/src/Utils" prefix Utils_;

  /**
   * @description A MerkleTree of role commitments stored as H(PK | role | nonce)
   * @type {Bytes<32>} roleCommitment - A roleCommitment created by the following hash: SHA256(PK | role | nonce).
   * @type {MerkleTree<10, roleCommitment>}
   * @type {MerkleTree<10, Bytes<32>>} _operatorRoles
   */
  export ledger _operatorRoles: MerkleTree<10, Bytes<32>>;

  /**
   * @description A set of nullifiers used to revoke permissions from a role
   * @type {Bytes<32>} roleCommitment - A roleCommitment created by the following hash: SHA256(PK | role | nonce).
   * @type {Set<Bytes<32>} _roleNullifiers
   */
  export ledger _roleNullifiers: Set<Bytes<32>>;

  /**
   * @description Mapping from a role identifier to an admin role identifier.
   * @type {Bytes<32>} roleId - A hash representing a role identifier.
   * @type {Bytes<32>} adminId - A hash representing an admin identifier.
   * @type {Map<roleId, adminId>}
   * @type {Map<Bytes<32>, Bytes<32>>} _adminRoles
   */
  export ledger _adminRoles: Map<Bytes<32>, Bytes<32>>;

  export ledger DEFAULT_ADMIN_ROLE: Bytes<32>;

  witness getRoleCommitmentPath(roleCommitment: Bytes<32>): MerkleTreePath<10, Bytes<32>>;

  /**
   * @description Returns `true` if `account` has been granted `roleId`.
   *
   * @circuitInfo
   *
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} account - The account to query.
   * @param {Bytes<32>} roleId - The role identifier.
   * @param {Bytes<32>} nonce - A nonce created using SHA256(SK | "role-nonce" | role | PK)
   * @return {Boolean} - Whether the account has the specified role.
   */
  export circuit hasRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>, nonce: Bytes<32>): Boolean {
    const roleCommitment = persistentHash<Vector<3, Bytes<32>>>([roleId, account.left.bytes, nonce]);
    const authPath = getRoleCommitmentPath(roleCommitment);
    const isNullified = _roleNullifiers.member(disclose(roleCommitment));
    return _operatorRoles
      .checkRoot(merkleTreePathRoot<10, Bytes<32>>(disclose(authPath))) && !isNullified;
  }

  /**
   * @description Reverts if `ownPublicKey()` is missing `roleId`.
   *
   * @circuitInfo
   *
   * Requirements:
   *
   * - The caller must have `roleId`.
   * - The caller must not be a ContractAddress
   *
   * @param {Bytes<32>} roleId - The role identifier.
   * @param {Bytes<32>} nonce - A nonce created using SHA256(SK | "role-nonce" | role | PK)
   * @return {[]} - Empty tuple.
   */
  export circuit assertOnlyRole(roleId: Bytes<32>, nonce: Bytes<32>): [] {
    _checkRole(
      roleId,
      left<ZswapCoinPublicKey,ContractAddress>(ownPublicKey()),
      nonce
    );
  }

  /**
   * @description Reverts if `account` is missing `roleId`.
   *
   * @circuitInfo
   *
   * Requirements:
   *
   * - `account` must have `roleId`.
   *
   * @param {Bytes<32>} roleId - The role identifier.
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} account - The account to query.
   * @param {Bytes<32>} nonce - A nonce created using SHA256(SK | "role-nonce" | role | PK)
   * @return {[]} - Empty tuple.
   */
  export circuit _checkRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>, nonce: Bytes<32>): [] {
    assert(hasRole(roleId, account, nonce), "ShieldedAccessControl: unauthorized account");
  }

  /**
   * @description Returns the admin role that controls `roleId` or
   * a byte array with all zero bytes if `roleId` doesn't exist. See {grantRole} and {revokeRole}.
   *
   * To change a role’s admin use {_setRoleAdmin}.
   *
   * @circuitInfo
   *
   * @param {Bytes<32>} roleId - The role identifier.
   * @return {Bytes<32>} roleAdmin - The admin role that controls `roleId`.
   */
  export circuit getRoleAdmin(roleId: Bytes<32>): Bytes<32> {
    if (_adminRoles.member(disclose(roleId))) {
      return _adminRoles.lookup(disclose(roleId));
    }
    return default<Bytes<32>>;
  }

  /**
   * @description Grants `roleId` to `account`.
   *
   * @circuitInfo
   *
   * Requirements:
   *
   * - `account` must not be a ContractAddress.
   * - The caller must have `roleId`'s admin role.
   *
   * @param {Bytes<32>} roleId - The role identifier.
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} account - A ZswapCoinPublicKey or ContractAddress.
   * @param {Bytes<32>} nonce - A nonce created using SHA256(SK | "role-nonce" | role | PK)
   * @return {[]} - Empty tuple.
   */
  export circuit grantRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>, nonce: Bytes<32>): [] {
    assertOnlyRole(getRoleAdmin(roleId), nonce);
    _grantRole(roleId, account, nonce);
  }

  /**
   * @description Revokes `roleId` from `account`.
   *
   * @circuitInfo
   *
   * Requirements:
   *
   * - The caller must have `roleId`'s admin role.
   *
   * @param {Bytes<32>} roleId - The role identifier.
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} account - A ZswapCoinPublicKey or ContractAddress.
   * @param {Bytes<32>} nonce - A nonce created using SHA256(SK | "role-nonce" | role | PK)
   * @return {[]} - Empty tuple.
   */
  export circuit revokeRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>, nonce: Bytes<32>): [] {
    assertOnlyRole(getRoleAdmin(roleId), nonce);
    _revokeRole(roleId, account, nonce);
  }

 /**
  * @description Revokes `roleId` from the calling account.
  *
  * @notice Roles are often managed via {grantRole} and {revokeRole}: this circuit's
  * purpose is to provide a mechanism for accounts to lose their privileges
  * if they are compromised (such as when a trusted device is misplaced).
  *
  * @circuitInfo
  *
  * Requirements:
  *
  * - The caller must be `callerConfirmation`.
  * - The caller must not be a `ContractAddress`.
  *
  * @param {Bytes<32>} roleId - The role identifier.
  * @param {Either<ZswapCoinPublicKey, ContractAddress>} callerConfirmation - A ZswapCoinPublicKey or ContractAddress.
   * @param {Bytes<32>} nonce - A nonce created using SHA256(SK | "role-nonce" | role | PK)
  * @return {[]} - Empty tuple.
  */
  export circuit renounceRole(roleId: Bytes<32>, callerConfirmation: Either<ZswapCoinPublicKey, ContractAddress>, nonce: Bytes<32>): [] {
    assert(callerConfirmation == left<ZswapCoinPublicKey,ContractAddress>(ownPublicKey()), "ShieldedAccessControl: bad confirmation");

    _revokeRole(roleId, callerConfirmation, nonce);
  }

  /**
   * @description Sets `adminRole` as `roleId`'s admin role.
   *
   * @circuitInfo
   *
   * @param {Bytes<32>} roleId - The role identifier.
   * @param {Bytes<32>} adminRole - The admin role identifier.
   * @return {[]} - Empty tuple.
   */
  export circuit _setRoleAdmin(roleId: Bytes<32>, adminRole: Bytes<32>): [] {
    _adminRoles.insert(disclose(roleId), disclose(adminRole));
  }

  /**
   * @description Attempts to grant `roleId` to `account` and returns a boolean indicating if `roleId` was granted.
   * Internal circuit without access restriction.
   *
   * @circuitInfo
   *
   * Requirements:
   *
   * - `account` must not be a ContractAddress.
   *
   * @param {Bytes<32>} roleId - The role identifier.
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} account - A ZswapCoinPublicKey or ContractAddress.
   * @param {Bytes<32>} nonce - A nonce created using SHA256(SK | "role-nonce" | role | PK)
   * @return {Boolean} roleGranted - A boolean indicating if `roleId` was granted.
   */
  export circuit _grantRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>, nonce: Bytes<32>): Boolean {
    assert(!Utils_isContractAddress(account), "ShieldedAccessControl: unsafe role approval");
    return _unsafeGrantRole(roleId, account, nonce);
  }

  /**
   * @description Attempts to grant `roleId` to `account` and returns a boolean indicating if `roleId` was granted.
   * Internal circuit without access restriction. It does NOT check if the role is granted to a ContractAddress.
   *
   * @circuitInfo
   *
   * @notice External smart contracts cannot call the token contract at this time, so granting a role to an ContractAddress may
   * render a circuit permanently inaccessible.
   *
   * @param {Bytes<32>} roleId - The role identifier.
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} account - A ZswapCoinPublicKey or ContractAddress.
   * @param {Bytes<32>} nonce - A nonce created using SHA256(SK | "role-nonce" | role | PK)
   * @return {Boolean} roleGranted - A boolean indicating if `role` was granted.
   */
  export circuit _unsafeGrantRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>, nonce: Bytes<32>): Boolean {
    if (hasRole(roleId, account, nonce)) {
      return false;
    }

    if (!Utils_isContractAddress(account)) {
      const roleCommitment = persistentHash<Vector<3, Bytes<32>>>([roleId, account.left.bytes, nonce]);
      _operatorRoles.insertHash(disclose(roleCommitment));
      return true;
    }

    const roleCommitment = persistentHash<Vector<3, Bytes<32>>>([roleId, account.right.bytes, nonce]);
    _operatorRoles.insertHash(disclose(roleCommitment));
    return true;
  }

  /**
   * @description Attempts to revoke `roleId` from `account` and returns a boolean indicating if `roleId` was revoked.
   * Internal circuit without access restriction.
   *
   * @circuitInfo
   *
   * @param {Bytes<32>} roleId - The role identifier.
   * @param {Bytes<32>} adminRole - The admin role identifier.
   * @param {Bytes<32>} nonce - A nonce created using SHA256(SK | "role-nonce" | role | PK)
   * @return {Boolean} roleRevoked - A boolean indicating if `roleId` was revoked.
   */
  export circuit _revokeRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>, nonce: Bytes<32>): Boolean {
    if (!hasRole(roleId, account, nonce)) {
      return false;
    }

    if(!Utils_isContractAddress(account)) {
      const roleCommitment = persistentHash<Vector<3, Bytes<32>>>([roleId, account.left.bytes, nonce]);
      _roleNullifiers.insert(disclose(roleCommitment));
      return true;
    }

    const roleCommitment = persistentHash<Vector<3, Bytes<32>>>([roleId, account.right.bytes, nonce]);
    _roleNullifiers.insert(disclose(roleCommitment));
    return true;
  }
}
